#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Module th√¥ng b√°o giao d·ªãch v√† ho·∫°t ƒë·ªông chi ti·∫øt qua Telegram

Module n√†y cung c·∫•p th√¥ng b√°o chi ti·∫øt v·ªÅ:
1. Th√¥ng tin giao d·ªãch (v√†o l·ªánh, ra l·ªánh, ch·ªët l√£i/l·ªó)
2. Ho·∫°t ƒë·ªông c·ªßa trailing stop
3. C·∫£nh b√°o th·ªã tr∆∞·ªùng
4. Ph√¢n t√≠ch c√°c c·∫∑p giao d·ªãch
5. Tr·∫°ng th√°i ho·∫°t ƒë·ªông h·ªá th·ªëng
6. L√Ω do kh√¥ng giao d·ªãch
7. C·∫≠p nh·∫≠t c·∫•u h√¨nh v√† chi·∫øn l∆∞·ª£c
"""

import os
import sys
import json
import time
import logging
import datetime
import threading
import traceback
from typing import Dict, List, Any, Optional, Union, Tuple
from collections import defaultdict

# Thi·∫øt l·∫≠p logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("detailed_notifications.log"),
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger("detailed_notifications")

# Import c√°c module c·∫ßn thi·∫øt
try:
    from telegram_notifier import TelegramNotifier
    # Th√™m c√°c module ph√¢n t√≠ch
    from analyze_no_trade_reasons import NoTradeReasonsAnalyzer
    from market_analysis_system import MarketAnalysisSystem
except ImportError as e:
    logger.error(f"L·ªói import module: {e}")
    logger.error("ƒê·∫£m b·∫£o ƒëang ch·∫°y t·ª´ th∆∞ m·ª•c g·ªëc c·ªßa d·ª± √°n")
    sys.exit(1)

class DetailedTradeNotifications:
    """Cung c·∫•p th√¥ng b√°o chi ti·∫øt v·ªÅ giao d·ªãch v√† ho·∫°t ƒë·ªông h·ªá th·ªëng"""
    
    def __init__(self, config_path: str = 'configs/telegram/telegram_notification_config.json'):
        """
        Kh·ªüi t·∫°o h·ªá th·ªëng th√¥ng b√°o chi ti·∫øt
        
        Args:
            config_path (str): ƒê∆∞·ªùng d·∫´n t·ªõi file c·∫•u h√¨nh Telegram
        """
        self.config_path = config_path
        self.notification_config = self._load_notification_config()
        
        # Kh·ªüi t·∫°o Telegram notifier
        self.telegram = TelegramNotifier()
        
        # Kh·ªüi t·∫°o c√°c c√¥ng c·ª• ph√¢n t√≠ch
        self.market_analyzer = MarketAnalysisSystem()
        self.no_trade_analyzer = NoTradeReasonsAnalyzer()
        
        # Th√¥ng tin theo d√µi
        self.last_notification_time = defaultdict(lambda: datetime.datetime.min)
        self.notification_cooldowns = {
            'trade_signal': 60,  # gi√¢y
            'market_alert': 300,  # gi√¢y
            'system_status': 1800,  # gi√¢y
            'trailing_stop': 300,  # gi√¢y
            'position_update': 600,  # gi√¢y
            'no_trade_reasons': 1800,  # gi√¢y
            'strategy_change': 300,  # gi√¢y
        }
        
        # Th√¥ng tin c√°c v·ªã th·∫ø ƒëang m·ªü
        self.active_positions = {}
        self.trailing_stops = {}
        
        # D·ªØ li·ªáu th·ªã tr∆∞·ªùng
        self.market_data = {}
        
        logger.info("ƒê√£ kh·ªüi t·∫°o h·ªá th·ªëng th√¥ng b√°o chi ti·∫øt")
    
    def _load_notification_config(self) -> Dict:
        """
        T·∫£i c·∫•u h√¨nh th√¥ng b√°o t·ª´ file
        
        Returns:
            Dict: C·∫•u h√¨nh th√¥ng b√°o
        """
        try:
            if os.path.exists(self.config_path):
                with open(self.config_path, 'r') as f:
                    config = json.load(f)
                    logger.info(f"ƒê√£ t·∫£i c·∫•u h√¨nh th√¥ng b√°o t·ª´ {self.config_path}")
                    return config
            
            # N·∫øu kh√¥ng t√¨m th·∫•y file, t·∫°o c·∫•u h√¨nh m·∫∑c ƒë·ªãnh
            default_config = {
                'enabled': True,
                'notification_types': {
                    'trade_signal': True,
                    'market_alert': True,
                    'system_status': True,
                    'trailing_stop': True,
                    'position_update': True,
                    'no_trade_reasons': True,
                    'strategy_change': True
                },
                'send_charts': True,
                'detailed_info': True,
                'max_symbols_per_message': 5,
                'cooldown_override': False
            }
            
            # L∆∞u c·∫•u h√¨nh m·∫∑c ƒë·ªãnh
            os.makedirs(os.path.dirname(self.config_path), exist_ok=True)
            with open(self.config_path, 'w') as f:
                json.dump(default_config, f, indent=4)
            
            logger.info(f"ƒê√£ t·∫°o c·∫•u h√¨nh th√¥ng b√°o m·∫∑c ƒë·ªãnh t·∫°i {self.config_path}")
            return default_config
        except Exception as e:
            logger.error(f"L·ªói khi t·∫£i c·∫•u h√¨nh th√¥ng b√°o: {str(e)}")
            return {
                'enabled': True,
                'notification_types': {
                    'trade_signal': True,
                    'market_alert': True,
                    'system_status': True,
                    'trailing_stop': True,
                    'position_update': True,
                    'no_trade_reasons': True,
                    'strategy_change': True
                },
                'send_charts': True,
                'detailed_info': True,
                'max_symbols_per_message': 5,
                'cooldown_override': False
            }
    
    def _check_cooldown(self, notification_type: str) -> bool:
        """
        Ki·ªÉm tra th·ªùi gian ch·ªù gi·ªØa c√°c th√¥ng b√°o
        
        Args:
            notification_type (str): Lo·∫°i th√¥ng b√°o
            
        Returns:
            bool: True n·∫øu c√≥ th·ªÉ g·ª≠i th√¥ng b√°o, False n·∫øu ƒëang trong th·ªùi gian ch·ªù
        """
        if self.notification_config.get('cooldown_override', False):
            return True
            
        now = datetime.datetime.now()
        last_time = self.last_notification_time[notification_type]
        cooldown = self.notification_cooldowns.get(notification_type, 60)  # m·∫∑c ƒë·ªãnh 60 gi√¢y
        
        if (now - last_time).total_seconds() < cooldown:
            return False
            
        self.last_notification_time[notification_type] = now
        return True
    
    def update_market_data(self, market_data: Dict) -> None:
        """
        C·∫≠p nh·∫≠t d·ªØ li·ªáu th·ªã tr∆∞·ªùng m·ªõi nh·∫•t
        
        Args:
            market_data (Dict): D·ªØ li·ªáu th·ªã tr∆∞·ªùng
        """
        self.market_data = market_data
        logger.info(f"ƒê√£ c·∫≠p nh·∫≠t d·ªØ li·ªáu th·ªã tr∆∞·ªùng cho {len(market_data)} c·∫∑p giao d·ªãch")
        
    def send_multi_symbol_analysis(self, symbols: List[str]) -> bool:
        """
        G·ª≠i ph√¢n t√≠ch ƒëa symbol
        
        Args:
            symbols: Danh s√°ch c√°c symbols c·∫ßn ph√¢n t√≠ch
            
        Returns:
            bool: True n·∫øu g·ª≠i th√†nh c√¥ng, False n·∫øu kh√¥ng
        """
        try:
            logger.info(f"ƒêang g·ª≠i ph√¢n t√≠ch ƒëa symbol: {symbols}")
            
            # Thu th·∫≠p d·ªØ li·ªáu ph√¢n t√≠ch cho t·ª´ng symbol
            analysis_data = {}
            
            for symbol in symbols:
                # L·∫•y ph√¢n t√≠ch t·ª´ market_analyzer
                result = self.market_analyzer.analyze_symbol(symbol)
                if result:
                    analysis_data[symbol] = result
            
            if not analysis_data:
                logger.warning("Kh√¥ng c√≥ d·ªØ li·ªáu ph√¢n t√≠ch n√†o ƒë·ªÉ g·ª≠i")
                return False
            
            # T·∫°o th√¥ng b√°o
            message = "<b>üìä PH√ÇN T√çCH ƒêA COIN</b>\n\n"
            
            # Th√™m th√¥ng tin cho t·ª´ng symbol
            for symbol, data in analysis_data.items():
                symbol_name = symbol.replace("USDT", "")
                current_price = data.get("current_price", 0)
                
                # L·∫•y th√¥ng tin t√≠n hi·ªáu
                summary = data.get("summary", {})
                signal = summary.get("overall_signal", "NEUTRAL")
                confidence = summary.get("confidence", 0)
                
                signal_emoji = "‚ö™"
                if signal in ["STRONG_BUY", "BUY", "Mua"]:
                    signal_emoji = "üü¢"
                elif signal in ["STRONG_SELL", "SELL", "B√°n"]:
                    signal_emoji = "üî¥"
                
                message += f"{signal_emoji} <b>{symbol_name} (${current_price:,.2f}):</b>\n"
                message += f"‚Ä¢ T√≠n hi·ªáu: {signal}\n"
                message += f"‚Ä¢ ƒê·ªô tin c·∫≠y: {confidence:.2f}%\n"
                
                # Th√™m th√¥ng tin h·ªó tr·ª£/kh√°ng c·ª±
                support_resistance = data.get("support_resistance", [])
                support = None
                resistance = None
                
                for level in support_resistance:
                    if level.get("type") == "H·ªó tr·ª£" and (support is None or level.get("value", 0) > support):
                        support = level.get("value", 0)
                    elif level.get("type") == "Kh√°ng c·ª±" and (resistance is None or level.get("value", 0) < resistance):
                        resistance = level.get("value", 0)
                
                if support:
                    message += f"‚Ä¢ H·ªó tr·ª£ g·∫ßn nh·∫•t: ${support:,.2f}\n"
                if resistance:
                    message += f"‚Ä¢ Kh√°ng c·ª± g·∫ßn nh·∫•t: ${resistance:,.2f}\n"
                
                # Th√™m xu h∆∞·ªõng
                if "short_term_trend" in data:
                    message += f"‚Ä¢ Xu h∆∞·ªõng ng·∫Øn h·∫°n: {data.get('short_term_trend', 'N/A')}\n"
                if "mid_term_trend" in data:
                    message += f"‚Ä¢ Xu h∆∞·ªõng trung h·∫°n: {data.get('mid_term_trend', 'N/A')}\n"
                
                message += "\n"
            
            # Th√™m th·ªùi gian
            message += f"‚è± <i>Th·ªùi gian: {datetime.datetime.now().strftime('%H:%M:%S %d/%m/%Y')}</i>"
            
            # G·ª≠i th√¥ng b√°o
            result = self.telegram.send_notification("info", message)
            
            if result:
                logger.info(f"ƒê√£ g·ª≠i ph√¢n t√≠ch ƒëa symbol ({', '.join(symbols)}) th√†nh c√¥ng")
                return True
            else:
                logger.error(f"L·ªói khi g·ª≠i ph√¢n t√≠ch ƒëa symbol")
                return False
                
        except Exception as e:
            logger.error(f"L·ªói khi g·ª≠i ph√¢n t√≠ch ƒëa symbol: {str(e)}")
            logger.error(traceback.format_exc())
            return False
    
    def update_positions(self, positions: Dict) -> None:
        """
        C·∫≠p nh·∫≠t th√¥ng tin c√°c v·ªã th·∫ø ƒëang m·ªü
        
        Args:
            positions (Dict): Th√¥ng tin v·ªã th·∫ø
        """
        # Ki·ªÉm tra v·ªã th·∫ø m·ªõi v√† g·ª≠i th√¥ng b√°o
        for symbol, position in positions.items():
            if symbol not in self.active_positions:
                # V·ªã th·∫ø m·ªõi
                self.send_new_position_notification(symbol, position)
            elif self._has_position_changed(self.active_positions[symbol], position):
                # V·ªã th·∫ø thay ƒë·ªïi
                self.send_position_update_notification(symbol, self.active_positions[symbol], position)
        
        # Ki·ªÉm tra v·ªã th·∫ø ƒë√£ ƒë√≥ng
        for symbol in list(self.active_positions.keys()):
            if symbol not in positions:
                # V·ªã th·∫ø ƒë√£ ƒë√≥ng
                self.send_position_closed_notification(symbol, self.active_positions[symbol])
        
        # C·∫≠p nh·∫≠t danh s√°ch v·ªã th·∫ø
        self.active_positions = positions.copy()
        logger.info(f"ƒê√£ c·∫≠p nh·∫≠t {len(positions)} v·ªã th·∫ø ƒëang m·ªü")
    
    def update_trailing_stops(self, trailing_stops: Dict) -> None:
        """
        C·∫≠p nh·∫≠t th√¥ng tin trailing stop
        
        Args:
            trailing_stops (Dict): Th√¥ng tin trailing stop
        """
        # Ki·ªÉm tra trailing stop m·ªõi v√† g·ª≠i th√¥ng b√°o
        for symbol, stop_info in trailing_stops.items():
            if symbol not in self.trailing_stops:
                # Trailing stop m·ªõi
                self.send_new_trailing_stop_notification(symbol, stop_info)
            elif self._has_trailing_stop_changed(self.trailing_stops[symbol], stop_info):
                # Trailing stop thay ƒë·ªïi
                self.send_trailing_stop_update_notification(symbol, self.trailing_stops[symbol], stop_info)
        
        # Ki·ªÉm tra trailing stop ƒë√£ x√≥a
        for symbol in list(self.trailing_stops.keys()):
            if symbol not in trailing_stops:
                # Trailing stop ƒë√£ x√≥a
                self.send_trailing_stop_removed_notification(symbol, self.trailing_stops[symbol])
        
        # C·∫≠p nh·∫≠t danh s√°ch trailing stop
        self.trailing_stops = trailing_stops.copy()
        logger.info(f"ƒê√£ c·∫≠p nh·∫≠t {len(trailing_stops)} trailing stop")
    
    def _has_position_changed(self, old_position: Dict, new_position: Dict) -> bool:
        """
        Ki·ªÉm tra xem v·ªã th·∫ø c√≥ thay ƒë·ªïi kh√¥ng
        
        Args:
            old_position (Dict): V·ªã th·∫ø c≈©
            new_position (Dict): V·ªã th·∫ø m·ªõi
            
        Returns:
            bool: True n·∫øu c√≥ thay ƒë·ªïi, False n·∫øu kh√¥ng
        """
        # Ki·ªÉm tra c√°c thay ƒë·ªïi quan tr·ªçng
        if float(old_position.get('positionAmt', 0)) != float(new_position.get('positionAmt', 0)):
            return True
        if float(old_position.get('entryPrice', 0)) != float(new_position.get('entryPrice', 0)):
            return True
        if float(old_position.get('leverage', 0)) != float(new_position.get('leverage', 0)):
            return True
        if float(old_position.get('unrealizedProfit', 0)) != float(new_position.get('unrealizedProfit', 0)):
            return True
        
        return False
    
    def _has_trailing_stop_changed(self, old_stop: Dict, new_stop: Dict) -> bool:
        """
        Ki·ªÉm tra xem trailing stop c√≥ thay ƒë·ªïi kh√¥ng
        
        Args:
            old_stop (Dict): Trailing stop c≈©
            new_stop (Dict): Trailing stop m·ªõi
            
        Returns:
            bool: True n·∫øu c√≥ thay ƒë·ªïi, False n·∫øu kh√¥ng
        """
        # Ki·ªÉm tra c√°c thay ƒë·ªïi quan tr·ªçng
        if float(old_stop.get('activation_price', 0)) != float(new_stop.get('activation_price', 0)):
            return True
        if float(old_stop.get('callback_rate', 0)) != float(new_stop.get('callback_rate', 0)):
            return True
        if old_stop.get('status', '') != new_stop.get('status', ''):
            return True
        if float(old_stop.get('current_price', 0)) != float(new_stop.get('current_price', 0)):
            return True
        
        return False
    
    def send_new_position_notification(self, symbol: str, position: Dict) -> bool:
        """
        G·ª≠i th√¥ng b√°o v·ªã th·∫ø m·ªõi
        
        Args:
            symbol (str): K√Ω hi·ªáu c·∫∑p giao d·ªãch
            position (Dict): Th√¥ng tin v·ªã th·∫ø
            
        Returns:
            bool: True n·∫øu th√†nh c√¥ng, False n·∫øu kh√¥ng
        """
        try:
            if not self._check_notification_enabled('trade_signal'):
                return False
                
            if not self._check_cooldown('trade_signal'):
                logger.info(f"B·ªè qua th√¥ng b√°o v·ªã th·∫ø m·ªõi cho {symbol} do ƒëang trong th·ªùi gian ch·ªù")
                return False
                
            logger.info(f"ƒêang g·ª≠i th√¥ng b√°o v·ªã th·∫ø m·ªõi cho {symbol}")
            
            # T·∫°o n·ªôi dung th√¥ng b√°o
            message = self._create_new_position_message(symbol, position)
            
            # G·ª≠i th√¥ng b√°o
            result = self.telegram.send_message(message, parse_mode="HTML")
            
            if result:
                logger.info(f"ƒê√£ g·ª≠i th√¥ng b√°o v·ªã th·∫ø m·ªõi cho {symbol}")
                return True
            else:
                logger.error(f"L·ªói khi g·ª≠i th√¥ng b√°o v·ªã th·∫ø m·ªõi cho {symbol}")
                return False
        except Exception as e:
            logger.error(f"L·ªói khi g·ª≠i th√¥ng b√°o v·ªã th·∫ø m·ªõi: {str(e)}")
            return False
    
    def _create_new_position_message(self, symbol: str, position: Dict) -> str:
        """
        T·∫°o n·ªôi dung th√¥ng b√°o v·ªã th·∫ø m·ªõi
        
        Args:
            symbol (str): K√Ω hi·ªáu c·∫∑p giao d·ªãch
            position (Dict): Th√¥ng tin v·ªã th·∫ø
            
        Returns:
            str: N·ªôi dung th√¥ng b√°o
        """
        try:
            # L·∫•y th√¥ng tin c∆° b·∫£n
            entry_price = float(position.get('entryPrice', 0))
            qty = float(position.get('positionAmt', 0))
            leverage = float(position.get('leverage', 1))
            
            # X√°c ƒë·ªãnh h∆∞·ªõng giao d·ªãch
            side = "LONG" if qty > 0 else "SHORT"
            emoji = "üü¢" if side == "LONG" else "üî¥"
            
            # L·∫•y gi√° hi·ªán t·∫°i
            current_price = float(position.get('markPrice', 0)) or self.market_data.get(symbol, 0)
            
            # T√≠nh l·ª£i nhu·∫≠n
            if side == "LONG":
                profit_percent = (current_price - entry_price) / entry_price * 100 * leverage
            else:
                profit_percent = (entry_price - current_price) / entry_price * 100 * leverage
                
            profit_icon = "üìà" if profit_percent > 0 else "üìâ"
            
            # T·∫°o th√¥ng b√°o
            message = f"{emoji} <b>V·ªä TH·∫æ M·ªöI - {symbol} {side}</b> {emoji}\n\n"
            message += f"üí∞ <b>Entry Price:</b> {entry_price:.4f}\n"
            message += f"üìä <b>S·ªë l∆∞·ª£ng:</b> {abs(qty):.4f}\n"
            message += f"üîÑ <b>ƒê√≤n b·∫©y:</b> {leverage}x\n"
            message += f"üíµ <b>Gi√° hi·ªán t·∫°i:</b> {current_price:.4f}\n"
            message += f"{profit_icon} <b>L·ª£i nhu·∫≠n:</b> {profit_percent:.2f}%\n\n"
            
            # Th√™m ph√¢n t√≠ch n·∫øu c√≥
            analysis = self._get_symbol_analysis(symbol)
            if analysis:
                message += "<b>PH√ÇN T√çCH K·ª∏ THU·∫¨T</b>\n"
                message += f"üìä <b>Xu h∆∞·ªõng:</b> {analysis.get('trend', 'N/A')}\n"
                message += f"üéØ <b>M·ª•c ti√™u:</b> {analysis.get('target_price', 'N/A')}\n"
                message += f"üõë <b>Stop Loss:</b> {analysis.get('stop_loss', 'N/A')}\n\n"
            
            # Th√™m th√¥ng tin th·ªùi gian
            message += f"<i>‚è±Ô∏è {datetime.datetime.now().strftime('%H:%M:%S %d/%m/%Y')}</i>"
            
            return message
        except Exception as e:
            logger.error(f"L·ªói khi t·∫°o th√¥ng b√°o v·ªã th·∫ø m·ªõi: {str(e)}")
            return f"<b>üîî V·ªä TH·∫æ M·ªöI - {symbol}</b>\n\nƒê√£ m·ªü v·ªã th·∫ø m·ªõi cho {symbol}.\nXem chi ti·∫øt trong ·ª©ng d·ª•ng."
    
    def send_position_update_notification(self, symbol: str, old_position: Dict, new_position: Dict) -> bool:
        """
        G·ª≠i th√¥ng b√°o c·∫≠p nh·∫≠t v·ªã th·∫ø
        
        Args:
            symbol (str): K√Ω hi·ªáu c·∫∑p giao d·ªãch
            old_position (Dict): Th√¥ng tin v·ªã th·∫ø c≈©
            new_position (Dict): Th√¥ng tin v·ªã th·∫ø m·ªõi
            
        Returns:
            bool: True n·∫øu th√†nh c√¥ng, False n·∫øu kh√¥ng
        """
        try:
            if not self._check_notification_enabled('position_update'):
                return False
                
            if not self._check_cooldown('position_update'):
                logger.info(f"B·ªè qua th√¥ng b√°o c·∫≠p nh·∫≠t v·ªã th·∫ø cho {symbol} do ƒëang trong th·ªùi gian ch·ªù")
                return False
                
            logger.info(f"ƒêang g·ª≠i th√¥ng b√°o c·∫≠p nh·∫≠t v·ªã th·∫ø cho {symbol}")
            
            # T·∫°o n·ªôi dung th√¥ng b√°o
            message = self._create_position_update_message(symbol, old_position, new_position)
            
            # G·ª≠i th√¥ng b√°o
            result = self.telegram.send_message(message, parse_mode="HTML")
            
            if result:
                logger.info(f"ƒê√£ g·ª≠i th√¥ng b√°o c·∫≠p nh·∫≠t v·ªã th·∫ø cho {symbol}")
                return True
            else:
                logger.error(f"L·ªói khi g·ª≠i th√¥ng b√°o c·∫≠p nh·∫≠t v·ªã th·∫ø cho {symbol}")
                return False
        except Exception as e:
            logger.error(f"L·ªói khi g·ª≠i th√¥ng b√°o c·∫≠p nh·∫≠t v·ªã th·∫ø: {str(e)}")
            return False
    
    def _create_position_update_message(self, symbol: str, old_position: Dict, new_position: Dict) -> str:
        """
        T·∫°o n·ªôi dung th√¥ng b√°o c·∫≠p nh·∫≠t v·ªã th·∫ø
        
        Args:
            symbol (str): K√Ω hi·ªáu c·∫∑p giao d·ªãch
            old_position (Dict): Th√¥ng tin v·ªã th·∫ø c≈©
            new_position (Dict): Th√¥ng tin v·ªã th·∫ø m·ªõi
            
        Returns:
            str: N·ªôi dung th√¥ng b√°o
        """
        try:
            # L·∫•y th√¥ng tin c∆° b·∫£n
            old_qty = float(old_position.get('positionAmt', 0))
            new_qty = float(new_position.get('positionAmt', 0))
            
            old_entry = float(old_position.get('entryPrice', 0))
            new_entry = float(new_position.get('entryPrice', 0))
            
            old_profit = float(old_position.get('unrealizedProfit', 0))
            new_profit = float(new_position.get('unrealizedProfit', 0))
            
            leverage = float(new_position.get('leverage', 1))
            
            # X√°c ƒë·ªãnh h∆∞·ªõng giao d·ªãch
            side = "LONG" if new_qty > 0 else "SHORT"
            emoji = "üü¢" if side == "LONG" else "üî¥"
            
            # L·∫•y gi√° hi·ªán t·∫°i
            current_price = float(new_position.get('markPrice', 0)) or self.market_data.get(symbol, 0)
            
            # T√≠nh l·ª£i nhu·∫≠n
            if side == "LONG":
                profit_percent = (current_price - new_entry) / new_entry * 100 * leverage
            else:
                profit_percent = (new_entry - current_price) / new_entry * 100 * leverage
                
            profit_icon = "üìà" if profit_percent > 0 else "üìâ"
            profit_change = new_profit - old_profit
            profit_change_icon = "üìà" if profit_change > 0 else "üìâ"
            
            # X√°c ƒë·ªãnh lo·∫°i c·∫≠p nh·∫≠t
            if abs(new_qty) > abs(old_qty):
                update_type = "üîº TƒÇNG V·ªä TH·∫æ"
            elif abs(new_qty) < abs(old_qty):
                update_type = "üîΩ GI·∫¢M V·ªä TH·∫æ"
            else:
                update_type = "üîÑ C·∫¨P NH·∫¨T V·ªä TH·∫æ"
            
            # T·∫°o th√¥ng b√°o
            message = f"{emoji} <b>{update_type} - {symbol} {side}</b> {emoji}\n\n"
            
            # Chi ti·∫øt thay ƒë·ªïi
            message += "<b>THAY ƒê·ªîI</b>\n"
            message += f"üìä <b>S·ªë l∆∞·ª£ng:</b> {abs(old_qty):.4f} ‚Üí {abs(new_qty):.4f}\n"
            message += f"üí∞ <b>Gi√° v√†o:</b> {old_entry:.4f} ‚Üí {new_entry:.4f}\n"
            message += f"{profit_change_icon} <b>Thay ƒë·ªïi l·ª£i nhu·∫≠n:</b> {profit_change:.2f} USDT\n\n"
            
            # Th√¥ng tin hi·ªán t·∫°i
            message += "<b>TR·∫†NG TH√ÅI HI·ªÜN T·∫†I</b>\n"
            message += f"üíµ <b>Gi√° hi·ªán t·∫°i:</b> {current_price:.4f}\n"
            message += f"{profit_icon} <b>L·ª£i nhu·∫≠n:</b> {profit_percent:.2f}% ({new_profit:.2f} USDT)\n"
            
            # Th√™m ph√¢n t√≠ch n·∫øu c√≥
            analysis = self._get_symbol_analysis(symbol)
            if analysis:
                message += "\n<b>PH√ÇN T√çCH K·ª∏ THU·∫¨T</b>\n"
                message += f"üìä <b>Xu h∆∞·ªõng:</b> {analysis.get('trend', 'N/A')}\n"
                message += f"üéØ <b>M·ª•c ti√™u:</b> {analysis.get('target_price', 'N/A')}\n"
                message += f"üõë <b>Stop Loss:</b> {analysis.get('stop_loss', 'N/A')}\n"
            
            # Th√™m th√¥ng tin trailing stop n·∫øu c√≥
            if symbol in self.trailing_stops:
                stop_info = self.trailing_stops[symbol]
                message += f"\n<b>TRAILING STOP</b>\n"
                message += f"‚öôÔ∏è <b>Tr·∫°ng th√°i:</b> {stop_info.get('status', 'N/A')}\n"
                message += f"üíπ <b>Gi√° k√≠ch ho·∫°t:</b> {stop_info.get('activation_price', 'N/A')}\n"
                message += f"üìâ <b>Callback Rate:</b> {stop_info.get('callback_rate', 'N/A')}%\n"
            
            # Th√™m th√¥ng tin th·ªùi gian
            message += f"\n<i>‚è±Ô∏è {datetime.datetime.now().strftime('%H:%M:%S %d/%m/%Y')}</i>"
            
            return message
        except Exception as e:
            logger.error(f"L·ªói khi t·∫°o th√¥ng b√°o c·∫≠p nh·∫≠t v·ªã th·∫ø: {str(e)}")
            return f"<b>üîî C·∫¨P NH·∫¨T V·ªä TH·∫æ - {symbol}</b>\n\nV·ªã th·∫ø c·ªßa {symbol} ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t.\nXem chi ti·∫øt trong ·ª©ng d·ª•ng."
    
    def send_position_closed_notification(self, symbol: str, position: Dict) -> bool:
        """
        G·ª≠i th√¥ng b√°o ƒë√≥ng v·ªã th·∫ø
        
        Args:
            symbol (str): K√Ω hi·ªáu c·∫∑p giao d·ªãch
            position (Dict): Th√¥ng tin v·ªã th·∫ø
            
        Returns:
            bool: True n·∫øu th√†nh c√¥ng, False n·∫øu kh√¥ng
        """
        try:
            if not self._check_notification_enabled('trade_signal'):
                return False
                
            logger.info(f"ƒêang g·ª≠i th√¥ng b√°o ƒë√≥ng v·ªã th·∫ø cho {symbol}")
            
            # T·∫°o n·ªôi dung th√¥ng b√°o
            message = self._create_position_closed_message(symbol, position)
            
            # G·ª≠i th√¥ng b√°o
            result = self.telegram.send_message(message, parse_mode="HTML")
            
            if result:
                logger.info(f"ƒê√£ g·ª≠i th√¥ng b√°o ƒë√≥ng v·ªã th·∫ø cho {symbol}")
                return True
            else:
                logger.error(f"L·ªói khi g·ª≠i th√¥ng b√°o ƒë√≥ng v·ªã th·∫ø cho {symbol}")
                return False
        except Exception as e:
            logger.error(f"L·ªói khi g·ª≠i th√¥ng b√°o ƒë√≥ng v·ªã th·∫ø: {str(e)}")
            return False
    
    def _create_position_closed_message(self, symbol: str, position: Dict) -> str:
        """
        T·∫°o n·ªôi dung th√¥ng b√°o ƒë√≥ng v·ªã th·∫ø
        
        Args:
            symbol (str): K√Ω hi·ªáu c·∫∑p giao d·ªãch
            position (Dict): Th√¥ng tin v·ªã th·∫ø
            
        Returns:
            str: N·ªôi dung th√¥ng b√°o
        """
        try:
            # L·∫•y th√¥ng tin c∆° b·∫£n
            entry_price = float(position.get('entryPrice', 0))
            qty = float(position.get('positionAmt', 0))
            leverage = float(position.get('leverage', 1))
            
            # X√°c ƒë·ªãnh h∆∞·ªõng giao d·ªãch
            side = "LONG" if qty > 0 else "SHORT"
            
            # L·∫•y gi√° ƒë√≥ng (gi√° hi·ªán t·∫°i)
            exit_price = float(position.get('markPrice', 0)) or self.market_data.get(symbol, 0)
            
            # T√≠nh l·ª£i nhu·∫≠n
            if side == "LONG":
                profit_percent = (exit_price - entry_price) / entry_price * 100 * leverage
            else:
                profit_percent = (entry_price - exit_price) / entry_price * 100 * leverage
                
            estimated_profit = abs(qty) * entry_price * profit_percent / 100
                
            # X√°c ƒë·ªãnh bi·ªÉu t∆∞·ª£ng d·ª±a tr√™n l·ª£i nhu·∫≠n
            if profit_percent > 0:
                result_emoji = "‚úÖ"
                result_text = "TH√ÄNH C√îNG"
            else:
                result_emoji = "‚ùå"
                result_text = "L·ªñ"
            
            # T·∫°o th√¥ng b√°o
            message = f"{result_emoji} <b>ƒê√ìNG V·ªä TH·∫æ {result_text} - {symbol} {side}</b> {result_emoji}\n\n"
            
            message += "<b>CHI TI·∫æT GIAO D·ªäCH</b>\n"
            message += f"üìä <b>S·ªë l∆∞·ª£ng:</b> {abs(qty):.4f}\n"
            message += f"üí∞ <b>Gi√° v√†o:</b> {entry_price:.4f}\n"
            message += f"üíµ <b>Gi√° ra:</b> {exit_price:.4f}\n"
            message += f"üîÑ <b>ƒê√≤n b·∫©y:</b> {leverage}x\n"
            
            if profit_percent > 0:
                message += f"üìà <b>L·ª£i nhu·∫≠n:</b> +{profit_percent:.2f}% (+{estimated_profit:.2f} USDT)\n\n"
            else:
                message += f"üìâ <b>L·ª£i nhu·∫≠n:</b> {profit_percent:.2f}% ({estimated_profit:.2f} USDT)\n\n"
            
            # Th√™m ph√¢n t√≠ch th·ªã tr∆∞·ªùng hi·ªán t·∫°i
            analysis = self._get_symbol_analysis(symbol)
            if analysis:
                message += "<b>PH√ÇN T√çCH TH·ªä TR∆Ø·ªúNG HI·ªÜN T·∫†I</b>\n"
                message += f"üìä <b>Xu h∆∞·ªõng:</b> {analysis.get('trend', 'N/A')}\n"
                message += f"üîç <b>T√≠n hi·ªáu:</b> {analysis.get('signal', 'N/A')}\n"
                message += f"üìù <b>Ghi ch√∫:</b> {analysis.get('note', 'N/A')}\n\n"
            
            # Th√™m th√¥ng tin th·ªùi gian
            message += f"<i>‚è±Ô∏è {datetime.datetime.now().strftime('%H:%M:%S %d/%m/%Y')}</i>"
            
            return message
        except Exception as e:
            logger.error(f"L·ªói khi t·∫°o th√¥ng b√°o ƒë√≥ng v·ªã th·∫ø: {str(e)}")
            return f"<b>üîî ƒê√ìNG V·ªä TH·∫æ - {symbol}</b>\n\nV·ªã th·∫ø c·ªßa {symbol} ƒë√£ ƒë∆∞·ª£c ƒë√≥ng.\nXem chi ti·∫øt trong ·ª©ng d·ª•ng."
    
    def send_new_trailing_stop_notification(self, symbol: str, stop_info: Dict) -> bool:
        """
        G·ª≠i th√¥ng b√°o trailing stop m·ªõi
        
        Args:
            symbol (str): K√Ω hi·ªáu c·∫∑p giao d·ªãch
            stop_info (Dict): Th√¥ng tin trailing stop
            
        Returns:
            bool: True n·∫øu th√†nh c√¥ng, False n·∫øu kh√¥ng
        """
        try:
            if not self._check_notification_enabled('trailing_stop'):
                return False
                
            if not self._check_cooldown('trailing_stop'):
                logger.info(f"B·ªè qua th√¥ng b√°o trailing stop m·ªõi cho {symbol} do ƒëang trong th·ªùi gian ch·ªù")
                return False
                
            logger.info(f"ƒêang g·ª≠i th√¥ng b√°o trailing stop m·ªõi cho {symbol}")
            
            # T·∫°o n·ªôi dung th√¥ng b√°o
            message = self._create_new_trailing_stop_message(symbol, stop_info)
            
            # G·ª≠i th√¥ng b√°o
            result = self.telegram.send_message(message, parse_mode="HTML")
            
            if result:
                logger.info(f"ƒê√£ g·ª≠i th√¥ng b√°o trailing stop m·ªõi cho {symbol}")
                return True
            else:
                logger.error(f"L·ªói khi g·ª≠i th√¥ng b√°o trailing stop m·ªõi cho {symbol}")
                return False
        except Exception as e:
            logger.error(f"L·ªói khi g·ª≠i th√¥ng b√°o trailing stop m·ªõi: {str(e)}")
            return False
    
    def _create_new_trailing_stop_message(self, symbol: str, stop_info: Dict) -> str:
        """
        T·∫°o n·ªôi dung th√¥ng b√°o trailing stop m·ªõi
        
        Args:
            symbol (str): K√Ω hi·ªáu c·∫∑p giao d·ªãch
            stop_info (Dict): Th√¥ng tin trailing stop
            
        Returns:
            str: N·ªôi dung th√¥ng b√°o
        """
        try:
            # L·∫•y th√¥ng tin trailing stop
            status = stop_info.get('status', 'ƒêang ch·ªù')
            activation_price = float(stop_info.get('activation_price', 0))
            callback_rate = float(stop_info.get('callback_rate', 0))
            current_price = float(stop_info.get('current_price', 0)) or self.market_data.get(symbol, 0)
            
            # L·∫•y th√¥ng tin v·ªã th·∫ø n·∫øu c√≥
            position = self.active_positions.get(symbol, {})
            side = "LONG" if float(position.get('positionAmt', 0)) > 0 else "SHORT"
            emoji = "üü¢" if side == "LONG" else "üî¥"
            
            # T·∫°o th√¥ng b√°o
            message = f"üîî <b>TRAILING STOP M·ªöI - {symbol} {side}</b>\n\n"
            
            message += "<b>C·∫§U H√åNH TRAILING STOP</b>\n"
            message += f"‚öôÔ∏è <b>Tr·∫°ng th√°i:</b> {status}\n"
            message += f"üíπ <b>Gi√° k√≠ch ho·∫°t:</b> {activation_price:.4f}\n"
            message += f"üìâ <b>Callback Rate:</b> {callback_rate:.2f}%\n"
            message += f"üíµ <b>Gi√° hi·ªán t·∫°i:</b> {current_price:.4f}\n\n"
            
            # Th√™m th√¥ng tin v·ªã th·∫ø n·∫øu c√≥
            if position:
                entry_price = float(position.get('entryPrice', 0))
                qty = float(position.get('positionAmt', 0))
                leverage = float(position.get('leverage', 1))
                
                # T√≠nh l·ª£i nhu·∫≠n
                if side == "LONG":
                    profit_percent = (current_price - entry_price) / entry_price * 100 * leverage
                    distance_percent = (activation_price - current_price) / current_price * 100
                else:
                    profit_percent = (entry_price - current_price) / entry_price * 100 * leverage
                    distance_percent = (current_price - activation_price) / current_price * 100
                    
                profit_icon = "üìà" if profit_percent > 0 else "üìâ"
                
                message += f"{emoji} <b>TH√îNG TIN V·ªä TH·∫æ</b>\n"
                message += f"üìä <b>S·ªë l∆∞·ª£ng:</b> {abs(qty):.4f}\n"
                message += f"üí∞ <b>Gi√° v√†o:</b> {entry_price:.4f}\n"
                message += f"{profit_icon} <b>L·ª£i nhu·∫≠n hi·ªán t·∫°i:</b> {profit_percent:.2f}%\n"
                message += f"üìè <b>Kho·∫£ng c√°ch ƒë·∫øn k√≠ch ho·∫°t:</b> {distance_percent:.2f}%\n\n"
            
            # Th√™m ph√¢n t√≠ch n·∫øu c√≥
            analysis = self._get_symbol_analysis(symbol)
            if analysis:
                message += "<b>PH√ÇN T√çCH K·ª∏ THU·∫¨T</b>\n"
                message += f"üìä <b>Xu h∆∞·ªõng:</b> {analysis.get('trend', 'N/A')}\n"
                message += f"üéØ <b>M·ª•c ti√™u:</b> {analysis.get('target_price', 'N/A')}\n\n"
            
            # Th√™m th√¥ng tin th·ªùi gian
            message += f"<i>‚è±Ô∏è {datetime.datetime.now().strftime('%H:%M:%S %d/%m/%Y')}</i>"
            
            return message
        except Exception as e:
            logger.error(f"L·ªói khi t·∫°o th√¥ng b√°o trailing stop m·ªõi: {str(e)}")
            return f"<b>üîî TRAILING STOP M·ªöI - {symbol}</b>\n\nƒê√£ thi·∫øt l·∫≠p trailing stop m·ªõi cho {symbol}.\nXem chi ti·∫øt trong ·ª©ng d·ª•ng."
    
    def send_trailing_stop_update_notification(self, symbol: str, old_stop: Dict, new_stop: Dict) -> bool:
        """
        G·ª≠i th√¥ng b√°o c·∫≠p nh·∫≠t trailing stop
        
        Args:
            symbol (str): K√Ω hi·ªáu c·∫∑p giao d·ªãch
            old_stop (Dict): Th√¥ng tin trailing stop c≈©
            new_stop (Dict): Th√¥ng tin trailing stop m·ªõi
            
        Returns:
            bool: True n·∫øu th√†nh c√¥ng, False n·∫øu kh√¥ng
        """
        try:
            if not self._check_notification_enabled('trailing_stop'):
                return False
                
            if not self._check_cooldown('trailing_stop'):
                logger.info(f"B·ªè qua th√¥ng b√°o c·∫≠p nh·∫≠t trailing stop cho {symbol} do ƒëang trong th·ªùi gian ch·ªù")
                return False
                
            logger.info(f"ƒêang g·ª≠i th√¥ng b√°o c·∫≠p nh·∫≠t trailing stop cho {symbol}")
            
            # T·∫°o n·ªôi dung th√¥ng b√°o
            message = self._create_trailing_stop_update_message(symbol, old_stop, new_stop)
            
            # G·ª≠i th√¥ng b√°o
            result = self.telegram.send_message(message, parse_mode="HTML")
            
            if result:
                logger.info(f"ƒê√£ g·ª≠i th√¥ng b√°o c·∫≠p nh·∫≠t trailing stop cho {symbol}")
                return True
            else:
                logger.error(f"L·ªói khi g·ª≠i th√¥ng b√°o c·∫≠p nh·∫≠t trailing stop cho {symbol}")
                return False
        except Exception as e:
            logger.error(f"L·ªói khi g·ª≠i th√¥ng b√°o c·∫≠p nh·∫≠t trailing stop: {str(e)}")
            return False
    
    def _create_trailing_stop_update_message(self, symbol: str, old_stop: Dict, new_stop: Dict) -> str:
        """
        T·∫°o n·ªôi dung th√¥ng b√°o c·∫≠p nh·∫≠t trailing stop
        
        Args:
            symbol (str): K√Ω hi·ªáu c·∫∑p giao d·ªãch
            old_stop (Dict): Th√¥ng tin trailing stop c≈©
            new_stop (Dict): Th√¥ng tin trailing stop m·ªõi
            
        Returns:
            str: N·ªôi dung th√¥ng b√°o
        """
        try:
            # L·∫•y th√¥ng tin trailing stop
            old_status = old_stop.get('status', 'ƒêang ch·ªù')
            new_status = new_stop.get('status', 'ƒêang ch·ªù')
            
            old_activation = float(old_stop.get('activation_price', 0))
            new_activation = float(new_stop.get('activation_price', 0))
            
            old_callback = float(old_stop.get('callback_rate', 0))
            new_callback = float(new_stop.get('callback_rate', 0))
            
            old_price = float(old_stop.get('current_price', 0))
            new_price = float(new_stop.get('current_price', 0)) or self.market_data.get(symbol, 0)
            
            # L·∫•y th√¥ng tin v·ªã th·∫ø n·∫øu c√≥
            position = self.active_positions.get(symbol, {})
            side = "LONG" if float(position.get('positionAmt', 0)) > 0 else "SHORT"
            emoji = "üü¢" if side == "LONG" else "üî¥"
            
            # X√°c ƒë·ªãnh lo·∫°i c·∫≠p nh·∫≠t
            if old_status != new_status and new_status == "ƒê√£ k√≠ch ho·∫°t":
                update_type = "üö® TRAILING STOP ƒê√É K√çCH HO·∫†T"
            elif old_status != new_status:
                update_type = "üîÑ TR·∫†NG TH√ÅI TRAILING STOP ƒê√É THAY ƒê·ªîI"
            elif old_activation != new_activation:
                update_type = "üîÑ GI√Å K√çCH HO·∫†T ƒê√É THAY ƒê·ªîI"
            elif old_callback != new_callback:
                update_type = "üîÑ CALLBACK RATE ƒê√É THAY ƒê·ªîI"
            else:
                update_type = "üîÑ C·∫¨P NH·∫¨T TRAILING STOP"
            
            # T·∫°o th√¥ng b√°o
            message = f"{emoji} <b>{update_type} - {symbol} {side}</b>\n\n"
            
            # Chi ti·∫øt thay ƒë·ªïi
            message += "<b>THAY ƒê·ªîI</b>\n"
            
            if old_status != new_status:
                message += f"‚öôÔ∏è <b>Tr·∫°ng th√°i:</b> {old_status} ‚Üí {new_status}\n"
                
            if old_activation != new_activation:
                message += f"üíπ <b>Gi√° k√≠ch ho·∫°t:</b> {old_activation:.4f} ‚Üí {new_activation:.4f}\n"
                
            if old_callback != new_callback:
                message += f"üìâ <b>Callback Rate:</b> {old_callback:.2f}% ‚Üí {new_callback:.2f}%\n"
                
            message += f"üíµ <b>Gi√° th·ªã tr∆∞·ªùng:</b> {old_price:.4f} ‚Üí {new_price:.4f}\n\n"
            
            # Th√™m th√¥ng tin v·ªã th·∫ø n·∫øu c√≥
            if position:
                entry_price = float(position.get('entryPrice', 0))
                qty = float(position.get('positionAmt', 0))
                leverage = float(position.get('leverage', 1))
                
                # T√≠nh l·ª£i nhu·∫≠n
                if side == "LONG":
                    profit_percent = (new_price - entry_price) / entry_price * 100 * leverage
                    if new_status == "ƒê√£ k√≠ch ho·∫°t":
                        trailing_price = new_price * (1 - new_callback/100) if side == "LONG" else new_price * (1 + new_callback/100)
                    else:
                        trailing_price = None
                else:
                    profit_percent = (entry_price - new_price) / entry_price * 100 * leverage
                    if new_status == "ƒê√£ k√≠ch ho·∫°t":
                        trailing_price = new_price * (1 + new_callback/100) if side == "SHORT" else new_price * (1 - new_callback/100)
                    else:
                        trailing_price = None
                    
                profit_icon = "üìà" if profit_percent > 0 else "üìâ"
                
                message += f"{emoji} <b>TH√îNG TIN V·ªä TH·∫æ</b>\n"
                message += f"üìä <b>S·ªë l∆∞·ª£ng:</b> {abs(qty):.4f}\n"
                message += f"üí∞ <b>Gi√° v√†o:</b> {entry_price:.4f}\n"
                message += f"{profit_icon} <b>L·ª£i nhu·∫≠n hi·ªán t·∫°i:</b> {profit_percent:.2f}%\n"
                
                if trailing_price:
                    message += f"üéØ <b>Gi√° trailing stop:</b> {trailing_price:.4f}\n\n"
                else:
                    message += "\n"
            
            # Th√™m ph√¢n t√≠ch n·∫øu c√≥
            analysis = self._get_symbol_analysis(symbol)
            if analysis:
                message += "<b>PH√ÇN T√çCH K·ª∏ THU·∫¨T</b>\n"
                message += f"üìä <b>Xu h∆∞·ªõng:</b> {analysis.get('trend', 'N/A')}\n"
                message += f"üéØ <b>M·ª•c ti√™u:</b> {analysis.get('target_price', 'N/A')}\n\n"
            
            # Th√™m th√¥ng tin th·ªùi gian
            message += f"<i>‚è±Ô∏è {datetime.datetime.now().strftime('%H:%M:%S %d/%m/%Y')}</i>"
            
            return message
        except Exception as e:
            logger.error(f"L·ªói khi t·∫°o th√¥ng b√°o c·∫≠p nh·∫≠t trailing stop: {str(e)}")
            return f"<b>üîî C·∫¨P NH·∫¨T TRAILING STOP - {symbol}</b>\n\nTrailing stop cho {symbol} ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t.\nXem chi ti·∫øt trong ·ª©ng d·ª•ng."
    
    def send_trailing_stop_removed_notification(self, symbol: str, stop_info: Dict) -> bool:
        """
        G·ª≠i th√¥ng b√°o x√≥a trailing stop
        
        Args:
            symbol (str): K√Ω hi·ªáu c·∫∑p giao d·ªãch
            stop_info (Dict): Th√¥ng tin trailing stop
            
        Returns:
            bool: True n·∫øu th√†nh c√¥ng, False n·∫øu kh√¥ng
        """
        try:
            if not self._check_notification_enabled('trailing_stop'):
                return False
                
            logger.info(f"ƒêang g·ª≠i th√¥ng b√°o x√≥a trailing stop cho {symbol}")
            
            # T·∫°o n·ªôi dung th√¥ng b√°o
            message = self._create_trailing_stop_removed_message(symbol, stop_info)
            
            # G·ª≠i th√¥ng b√°o
            result = self.telegram.send_message(message, parse_mode="HTML")
            
            if result:
                logger.info(f"ƒê√£ g·ª≠i th√¥ng b√°o x√≥a trailing stop cho {symbol}")
                return True
            else:
                logger.error(f"L·ªói khi g·ª≠i th√¥ng b√°o x√≥a trailing stop cho {symbol}")
                return False
        except Exception as e:
            logger.error(f"L·ªói khi g·ª≠i th√¥ng b√°o x√≥a trailing stop: {str(e)}")
            return False
    
    def _create_trailing_stop_removed_message(self, symbol: str, stop_info: Dict) -> str:
        """
        T·∫°o n·ªôi dung th√¥ng b√°o x√≥a trailing stop
        
        Args:
            symbol (str): K√Ω hi·ªáu c·∫∑p giao d·ªãch
            stop_info (Dict): Th√¥ng tin trailing stop
            
        Returns:
            str: N·ªôi dung th√¥ng b√°o
        """
        try:
            # L·∫•y th√¥ng tin trailing stop
            status = stop_info.get('status', 'ƒêang ch·ªù')
            activation_price = float(stop_info.get('activation_price', 0))
            callback_rate = float(stop_info.get('callback_rate', 0))
            
            # L·∫•y th√¥ng tin v·ªã th·∫ø n·∫øu c√≥
            position = self.active_positions.get(symbol, {})
            if position:
                side = "LONG" if float(position.get('positionAmt', 0)) > 0 else "SHORT"
                emoji = "üü¢" if side == "LONG" else "üî¥"
            else:
                side = "N/A"
                emoji = "‚ö™"
            
            # T·∫°o th√¥ng b√°o
            message = f"üö´ <b>TRAILING STOP ƒê√É X√ìA - {symbol} {side}</b>\n\n"
            
            message += "<b>TH√îNG TIN TRAILING STOP ƒê√É X√ìA</b>\n"
            message += f"‚öôÔ∏è <b>Tr·∫°ng th√°i:</b> {status}\n"
            message += f"üíπ <b>Gi√° k√≠ch ho·∫°t:</b> {activation_price:.4f}\n"
            message += f"üìâ <b>Callback Rate:</b> {callback_rate:.2f}%\n\n"
            
            # Th√™m th√¥ng tin hi·ªán t·∫°i c·ªßa th·ªã tr∆∞·ªùng
            current_price = self.market_data.get(symbol, 0)
            if current_price:
                message += f"üíµ <b>Gi√° hi·ªán t·∫°i:</b> {current_price:.4f}\n\n"
            
            # Th√™m ph√¢n t√≠ch n·∫øu c√≥
            analysis = self._get_symbol_analysis(symbol)
            if analysis:
                message += "<b>PH√ÇN T√çCH K·ª∏ THU·∫¨T</b>\n"
                message += f"üìä <b>Xu h∆∞·ªõng:</b> {analysis.get('trend', 'N/A')}\n"
                message += f"üéØ <b>M·ª•c ti√™u:</b> {analysis.get('target_price', 'N/A')}\n\n"
            
            # Th√™m th√¥ng tin th·ªùi gian
            message += f"<i>‚è±Ô∏è {datetime.datetime.now().strftime('%H:%M:%S %d/%m/%Y')}</i>"
            
            return message
        except Exception as e:
            logger.error(f"L·ªói khi t·∫°o th√¥ng b√°o x√≥a trailing stop: {str(e)}")
            return f"<b>üîî X√ìA TRAILING STOP - {symbol}</b>\n\nTrailing stop cho {symbol} ƒë√£ b·ªã x√≥a.\nXem chi ti·∫øt trong ·ª©ng d·ª•ng."
    
    def send_market_alert(self, symbol: str, alert_type: str, alert_data: Dict) -> bool:
        """
        G·ª≠i c·∫£nh b√°o th·ªã tr∆∞·ªùng
        
        Args:
            symbol (str): K√Ω hi·ªáu c·∫∑p giao d·ªãch
            alert_type (str): Lo·∫°i c·∫£nh b√°o (price, volatility, trend, ...)
            alert_data (Dict): D·ªØ li·ªáu c·∫£nh b√°o
            
        Returns:
            bool: True n·∫øu th√†nh c√¥ng, False n·∫øu kh√¥ng
        """
        try:
            if not self._check_notification_enabled('market_alert'):
                return False
                
            if not self._check_cooldown('market_alert'):
                logger.info(f"B·ªè qua c·∫£nh b√°o th·ªã tr∆∞·ªùng cho {symbol} do ƒëang trong th·ªùi gian ch·ªù")
                return False
                
            logger.info(f"ƒêang g·ª≠i c·∫£nh b√°o th·ªã tr∆∞·ªùng cho {symbol}, lo·∫°i: {alert_type}")
            
            # T·∫°o n·ªôi dung th√¥ng b√°o
            message = self._create_market_alert_message(symbol, alert_type, alert_data)
            
            # G·ª≠i th√¥ng b√°o
            result = self.telegram.send_message(message, parse_mode="HTML")
            
            if result:
                logger.info(f"ƒê√£ g·ª≠i c·∫£nh b√°o th·ªã tr∆∞·ªùng cho {symbol}")
                return True
            else:
                logger.error(f"L·ªói khi g·ª≠i c·∫£nh b√°o th·ªã tr∆∞·ªùng cho {symbol}")
                return False
        except Exception as e:
            logger.error(f"L·ªói khi g·ª≠i c·∫£nh b√°o th·ªã tr∆∞·ªùng: {str(e)}")
            return False
    
    def _create_market_alert_message(self, symbol: str, alert_type: str, alert_data: Dict) -> str:
        """
        T·∫°o n·ªôi dung th√¥ng b√°o c·∫£nh b√°o th·ªã tr∆∞·ªùng
        
        Args:
            symbol (str): K√Ω hi·ªáu c·∫∑p giao d·ªãch
            alert_type (str): Lo·∫°i c·∫£nh b√°o (price, volatility, trend, ...)
            alert_data (Dict): D·ªØ li·ªáu c·∫£nh b√°o
            
        Returns:
            str: N·ªôi dung th√¥ng b√°o
        """
        try:
            # X√°c ƒë·ªãnh lo·∫°i c·∫£nh b√°o v√† bi·ªÉu t∆∞·ª£ng
            alert_title = ""
            alert_emoji = ""
            
            if alert_type == "price":
                alert_title = "C·∫¢NH B√ÅO GI√Å"
                alert_emoji = "üí∞"
            elif alert_type == "volatility":
                alert_title = "C·∫¢NH B√ÅO BI·∫æN ƒê·ªòNG"
                alert_emoji = "üìä"
            elif alert_type == "trend":
                alert_title = "C·∫¢NH B√ÅO XU H∆Ø·ªöNG"
                alert_emoji = "üìà"
            elif alert_type == "volume":
                alert_title = "C·∫¢NH B√ÅO KH·ªêI L∆Ø·ª¢NG"
                alert_emoji = "üì¶"
            elif alert_type == "breakout":
                alert_title = "C·∫¢NH B√ÅO BREAKOUT"
                alert_emoji = "üöÄ"
            elif alert_type == "support_resistance":
                alert_title = "C·∫¢NH B√ÅO H·ªñ TR·ª¢/KH√ÅNG C·ª∞"
                alert_emoji = "üß±"
            else:
                alert_title = "C·∫¢NH B√ÅO TH·ªä TR∆Ø·ªúNG"
                alert_emoji = "‚ö†Ô∏è"
            
            # T·∫°o th√¥ng b√°o
            message = f"{alert_emoji} <b>{alert_title} - {symbol}</b> {alert_emoji}\n\n"
            
            # N·ªôi dung c·∫£nh b√°o
            message += f"<b>{alert_data.get('title', 'Th√¥ng tin c·∫£nh b√°o')}</b>\n"
            message += f"{alert_data.get('description', 'Kh√¥ng c√≥ m√¥ t·∫£')}\n\n"
            
            # Th√¥ng tin chi ti·∫øt
            message += "<b>CHI TI·∫æT</b>\n"
            
            for key, value in alert_data.get('details', {}).items():
                if key not in ['title', 'description']:
                    message += f"‚Ä¢ <b>{key}:</b> {value}\n"
            
            message += "\n"
            
            # L·∫•y th√¥ng tin v·ªã th·∫ø n·∫øu c√≥
            if symbol in self.active_positions:
                position = self.active_positions[symbol]
                side = "LONG" if float(position.get('positionAmt', 0)) > 0 else "SHORT"
                emoji = "üü¢" if side == "LONG" else "üî¥"
                
                message += f"{emoji} <b>V·ªä TH·∫æ ƒêANG M·ªû</b>\n"
                message += f"üìä <b>Lo·∫°i:</b> {side}\n"
                message += f"üí∞ <b>Gi√° v√†o:</b> {float(position.get('entryPrice', 0)):.4f}\n"
                message += f"üìè <b>S·ªë l∆∞·ª£ng:</b> {abs(float(position.get('positionAmt', 0))):.4f}\n\n"
            
            # Th√™m khuy·∫øn ngh·ªã n·∫øu c√≥
            if 'recommendation' in alert_data:
                message += f"üîç <b>KHUY·∫æN NGH·ªä</b>\n"
                message += f"{alert_data['recommendation']}\n\n"
            
            # Th√™m th√¥ng tin th·ªùi gian
            message += f"<i>‚è±Ô∏è {datetime.datetime.now().strftime('%H:%M:%S %d/%m/%Y')}</i>"
            
            return message
        except Exception as e:
            logger.error(f"L·ªói khi t·∫°o th√¥ng b√°o c·∫£nh b√°o th·ªã tr∆∞·ªùng: {str(e)}")
            return f"<b>‚ö†Ô∏è C·∫¢NH B√ÅO TH·ªä TR∆Ø·ªúNG - {symbol}</b>\n\n{alert_data.get('title', 'C√≥ c·∫£nh b√°o m·ªõi')}\n\nXem chi ti·∫øt trong ·ª©ng d·ª•ng."
    
    def send_no_trade_reasons(self, symbol: str, timeframe: str = "1h", direction: str = "long") -> bool:
        """
        G·ª≠i th√¥ng b√°o l√Ω do kh√¥ng giao d·ªãch
        
        Args:
            symbol (str): K√Ω hi·ªáu c·∫∑p giao d·ªãch
            timeframe (str): Khung th·ªùi gian
            direction (str): H∆∞·ªõng giao d·ªãch (long/short)
            
        Returns:
            bool: True n·∫øu th√†nh c√¥ng, False n·∫øu kh√¥ng
        """
        try:
            if not self._check_notification_enabled('no_trade_reasons'):
                return False
                
            if not self._check_cooldown('no_trade_reasons'):
                logger.info(f"B·ªè qua th√¥ng b√°o l√Ω do kh√¥ng giao d·ªãch cho {symbol} do ƒëang trong th·ªùi gian ch·ªù")
                return False
                
            logger.info(f"ƒêang g·ª≠i th√¥ng b√°o l√Ω do kh√¥ng giao d·ªãch cho {symbol} ({timeframe}, {direction})")
            
            # Ph√¢n t√≠ch l√Ω do kh√¥ng giao d·ªãch
            analysis = self.no_trade_analyzer.analyze_no_trade_reasons(symbol, timeframe, direction)
            
            # T·∫°o n·ªôi dung th√¥ng b√°o
            message = self._create_no_trade_reasons_message(symbol, timeframe, direction, analysis)
            
            # G·ª≠i th√¥ng b√°o
            result = self.telegram.send_message(message, parse_mode="HTML")
            
            if result:
                logger.info(f"ƒê√£ g·ª≠i th√¥ng b√°o l√Ω do kh√¥ng giao d·ªãch cho {symbol}")
                return True
            else:
                logger.error(f"L·ªói khi g·ª≠i th√¥ng b√°o l√Ω do kh√¥ng giao d·ªãch cho {symbol}")
                return False
        except Exception as e:
            logger.error(f"L·ªói khi g·ª≠i th√¥ng b√°o l√Ω do kh√¥ng giao d·ªãch: {str(e)}")
            return False
    
    def _create_no_trade_reasons_message(self, symbol: str, timeframe: str, direction: str, analysis: Dict) -> str:
        """
        T·∫°o n·ªôi dung th√¥ng b√°o l√Ω do kh√¥ng giao d·ªãch
        
        Args:
            symbol (str): K√Ω hi·ªáu c·∫∑p giao d·ªãch
            timeframe (str): Khung th·ªùi gian
            direction (str): H∆∞·ªõng giao d·ªãch (long/short)
            analysis (Dict): K·∫øt qu·∫£ ph√¢n t√≠ch
            
        Returns:
            str: N·ªôi dung th√¥ng b√°o
        """
        try:
            # X√°c ƒë·ªãnh bi·ªÉu t∆∞·ª£ng cho h∆∞·ªõng giao d·ªãch
            direction_emoji = "üü¢" if direction.lower() == "long" else "üî¥"
            direction_text = "LONG" if direction.lower() == "long" else "SHORT"
            
            # T·∫°o th√¥ng b√°o
            message = f"üîç <b>L√ù DO KH√îNG GIAO D·ªäCH - {symbol} {direction_text} ({timeframe})</b>\n\n"
            
            # L·∫•y c√°c l√Ω do kh√¥ng giao d·ªãch
            no_trade_reasons = analysis.get('no_trade_reasons', [])
            
            if not no_trade_reasons:
                message += "<i>Kh√¥ng t√¨m th·∫•y l√Ω do kh√¥ng giao d·ªãch. C√≥ th·ªÉ th·ªã tr∆∞·ªùng ƒë√£ ƒë·ªß ƒëi·ªÅu ki·ªán ƒë·ªÉ giao d·ªãch.</i>\n\n"
            else:
                # Th√™m c√°c l√Ω do kh√¥ng giao d·ªãch
                message += f"<b>C√ÅC L√ù DO KH√îNG GIAO D·ªäCH ({len(no_trade_reasons)})</b>\n"
                
                for i, reason in enumerate(no_trade_reasons, 1):
                    message += f"{i}. {reason.get('reason', 'Kh√¥ng x√°c ƒë·ªãnh')}\n"
                    
                    # Th√™m chi ti·∫øt n·∫øu c√≥
                    details = reason.get('details', {})
                    if details:
                        for key, value in details.items():
                            message += f"   - {key}: {value}\n"
                
                message += "\n"
            
            # Th√™m c√°c ƒëi·ªÅu ki·ªán c·∫ßn thi·∫øt ƒë·ªÉ giao d·ªãch
            required_conditions = analysis.get('required_conditions', [])
            
            if required_conditions:
                message += "<b>ƒêI·ªÄU KI·ªÜN C·∫¶N ƒê·ªÇ GIAO D·ªäCH</b>\n"
                
                for i, condition in enumerate(required_conditions, 1):
                    message += f"{i}. {condition.get('description', 'Kh√¥ng x√°c ƒë·ªãnh')}\n"
                    message += f"   - Hi·ªán t·∫°i: {condition.get('current_value', 'N/A')}\n"
                    message += f"   - C·∫ßn ƒë·∫°t: {condition.get('required_value', 'N/A')}\n"
                
                message += "\n"
            
            # Th√™m ph√¢n t√≠ch th·ªã tr∆∞·ªùng hi·ªán t·∫°i
            market_analysis = analysis.get('market_analysis', {})
            
            if market_analysis:
                message += "<b>PH√ÇN T√çCH TH·ªä TR∆Ø·ªúNG HI·ªÜN T·∫†I</b>\n"
                current_price = market_analysis.get('price', self.market_data.get(symbol, 0))
                
                message += f"üíµ <b>Gi√° hi·ªán t·∫°i:</b> {current_price:.4f}\n"
                message += f"üìä <b>Xu h∆∞·ªõng:</b> {market_analysis.get('trend', 'N/A')}\n"
                message += f"üìà <b>RSI:</b> {market_analysis.get('rsi', 'N/A')}\n"
                message += f"üìâ <b>MACD:</b> {market_analysis.get('macd', 'N/A')}\n"
                message += f"üìä <b>Bollinger Bands:</b> {market_analysis.get('bollinger', 'N/A')}\n\n"
            
            # Th√™m th√¥ng tin th·ªùi gian
            message += f"<i>‚è±Ô∏è {datetime.datetime.now().strftime('%H:%M:%S %d/%m/%Y')}</i>"
            
            return message
        except Exception as e:
            logger.error(f"L·ªói khi t·∫°o th√¥ng b√°o l√Ω do kh√¥ng giao d·ªãch: {str(e)}")
            return f"<b>üîç L√ù DO KH√îNG GIAO D·ªäCH - {symbol} {direction} ({timeframe})</b>\n\nKh√¥ng th·ªÉ th·ª±c hi·ªán ph√¢n t√≠ch chi ti·∫øt. Vui l√≤ng ki·ªÉm tra trong ·ª©ng d·ª•ng."
    
    def send_system_status(self) -> bool:
        """
        G·ª≠i th√¥ng b√°o tr·∫°ng th√°i h·ªá th·ªëng
        
        Returns:
            bool: True n·∫øu th√†nh c√¥ng, False n·∫øu kh√¥ng
        """
        try:
            if not self._check_notification_enabled('system_status'):
                return False
                
            if not self._check_cooldown('system_status'):
                logger.info("B·ªè qua th√¥ng b√°o tr·∫°ng th√°i h·ªá th·ªëng do ƒëang trong th·ªùi gian ch·ªù")
                return False
                
            logger.info("ƒêang g·ª≠i th√¥ng b√°o tr·∫°ng th√°i h·ªá th·ªëng")
            
            # T·∫°o n·ªôi dung th√¥ng b√°o
            message = self._create_system_status_message()
            
            # G·ª≠i th√¥ng b√°o
            result = self.telegram.send_message(message, parse_mode="HTML")
            
            if result:
                logger.info("ƒê√£ g·ª≠i th√¥ng b√°o tr·∫°ng th√°i h·ªá th·ªëng")
                return True
            else:
                logger.error("L·ªói khi g·ª≠i th√¥ng b√°o tr·∫°ng th√°i h·ªá th·ªëng")
                return False
        except Exception as e:
            logger.error(f"L·ªói khi g·ª≠i th√¥ng b√°o tr·∫°ng th√°i h·ªá th·ªëng: {str(e)}")
            return False
    
    def _create_system_status_message(self) -> str:
        """
        T·∫°o n·ªôi dung th√¥ng b√°o tr·∫°ng th√°i h·ªá th·ªëng
        
        Returns:
            str: N·ªôi dung th√¥ng b√°o
        """
        try:
            # T·∫°o th√¥ng b√°o
            message = "ü§ñ <b>B√ÅO C√ÅO TR·∫†NG TH√ÅI H·ªÜ TH·ªêNG</b>\n\n"
            
            # Th√¥ng tin v·ªã th·∫ø
            active_positions = len(self.active_positions)
            message += f"üìä <b>V·ªä TH·∫æ ƒêANG M·ªû:</b> {active_positions}\n"
            
            if active_positions > 0:
                message += "<b>Danh s√°ch v·ªã th·∫ø:</b>\n"
                
                for symbol, position in self.active_positions.items():
                    side = "LONG" if float(position.get('positionAmt', 0)) > 0 else "SHORT"
                    qty = abs(float(position.get('positionAmt', 0)))
                    entry = float(position.get('entryPrice', 0))
                    profit = float(position.get('unrealizedProfit', 0))
                    profit_emoji = "üìà" if profit > 0 else "üìâ"
                    
                    message += f"  ‚Ä¢ {symbol} {side}: {qty:.4f} @ {entry:.4f} {profit_emoji} {profit:.2f} USDT\n"
                
                message += "\n"
            
            # Th√¥ng tin trailing stop
            active_stops = len(self.trailing_stops)
            message += f"üéØ <b>TRAILING STOP ƒêANG HO·∫†T ƒê·ªòNG:</b> {active_stops}\n"
            
            if active_stops > 0:
                message += "<b>Danh s√°ch trailing stop:</b>\n"
                
                for symbol, stop in self.trailing_stops.items():
                    status = stop.get('status', 'ƒêang ch·ªù')
                    activation = float(stop.get('activation_price', 0))
                    callback = float(stop.get('callback_rate', 0))
                    status_emoji = "‚úÖ" if status == "ƒê√£ k√≠ch ho·∫°t" else "‚è≥"
                    
                    message += f"  ‚Ä¢ {symbol}: {status_emoji} {status}, K√≠ch ho·∫°t @ {activation:.4f}, Callback {callback:.2f}%\n"
                
                message += "\n"
            
            # Th√¥ng tin ph√¢n t√≠ch th·ªã tr∆∞·ªùng
            symbols_analyzed = len(self.market_data)
            message += f"üìä <b>C·∫∂P GIAO D·ªäCH ƒêANG PH√ÇN T√çCH:</b> {symbols_analyzed}\n\n"
            
            # Th√¥ng tin h·ªá th·ªëng
            start_time = self._get_system_start_time()
            uptime = self._get_system_uptime(start_time)
            
            message += f"‚è±Ô∏è <b>TH·ªúI GIAN HO·∫†T ƒê·ªòNG:</b> {uptime}\n"
            message += f"üîå <b>TR·∫†NG TH√ÅI K·∫æT N·ªêI:</b> ‚úÖ Ho·∫°t ƒë·ªông\n"
            message += f"üíæ <b>B·ªò NH·ªö ƒê√É S·ª¨ D·ª§NG:</b> {self._get_memory_usage()}MB\n"
            message += f"üìü <b>CPU ƒê√É S·ª¨ D·ª§NG:</b> {self._get_cpu_usage()}%\n\n"
            
            # Th√™m th√¥ng tin th·ªùi gian
            message += f"<i>‚è±Ô∏è {datetime.datetime.now().strftime('%H:%M:%S %d/%m/%Y')}</i>"
            
            return message
        except Exception as e:
            logger.error(f"L·ªói khi t·∫°o th√¥ng b√°o tr·∫°ng th√°i h·ªá th·ªëng: {str(e)}")
            return "<b>ü§ñ B√ÅO C√ÅO TR·∫†NG TH√ÅI H·ªÜ TH·ªêNG</b>\n\nH·ªá th·ªëng ƒëang ho·∫°t ƒë·ªông, nh∆∞ng kh√¥ng th·ªÉ t·∫°o b√°o c√°o chi ti·∫øt."
    
    def _get_system_start_time(self) -> datetime.datetime:
        """
        L·∫•y th·ªùi gian b·∫Øt ƒë·∫ßu c·ªßa h·ªá th·ªëng
        
        Returns:
            datetime.datetime: Th·ªùi gian b·∫Øt ƒë·∫ßu
        """
        try:
            # N·∫øu c√≥ file pid, h√£y ki·ªÉm tra th·ªùi gian t·∫°o
            pid_files = [f for f in os.listdir('.') if f.endswith('.pid')]
            
            if pid_files:
                oldest_file = min(pid_files, key=lambda x: os.path.getctime(x))
                return datetime.datetime.fromtimestamp(os.path.getctime(oldest_file))
            
            # N·∫øu kh√¥ng c√≥ file pid, s·ª≠ d·ª•ng th·ªùi gian hi·ªán t·∫°i tr·ª´ 1 gi·ªù
            return datetime.datetime.now() - datetime.timedelta(hours=1)
        except Exception as e:
            logger.error(f"L·ªói khi l·∫•y th·ªùi gian b·∫Øt ƒë·∫ßu h·ªá th·ªëng: {str(e)}")
            return datetime.datetime.now() - datetime.timedelta(hours=1)
    
    def _get_system_uptime(self, start_time: datetime.datetime = None) -> str:
        """
        T√≠nh th·ªùi gian ho·∫°t ƒë·ªông c·ªßa h·ªá th·ªëng
        
        Args:
            start_time (datetime.datetime): Th·ªùi gian b·∫Øt ƒë·∫ßu
            
        Returns:
            str: Th·ªùi gian ho·∫°t ƒë·ªông ƒë·ªãnh d·∫°ng
        """
        try:
            if not start_time:
                start_time = self._get_system_start_time()
                
            now = datetime.datetime.now()
            uptime = now - start_time
            
            days = uptime.days
            hours, remainder = divmod(uptime.seconds, 3600)
            minutes, seconds = divmod(remainder, 60)
            
            if days > 0:
                return f"{days} ng√†y, {hours} gi·ªù, {minutes} ph√∫t"
            elif hours > 0:
                return f"{hours} gi·ªù, {minutes} ph√∫t"
            else:
                return f"{minutes} ph√∫t, {seconds} gi√¢y"
        except Exception as e:
            logger.error(f"L·ªói khi t√≠nh th·ªùi gian ho·∫°t ƒë·ªông: {str(e)}")
            return "Kh√¥ng x√°c ƒë·ªãnh"
    
    def _get_memory_usage(self) -> float:
        """
        L·∫•y l∆∞·ª£ng b·ªô nh·ªõ ƒë√£ s·ª≠ d·ª•ng
        
        Returns:
            float: B·ªô nh·ªõ ƒë√£ s·ª≠ d·ª•ng (MB)
        """
        try:
            import psutil
            process = psutil.Process(os.getpid())
            memory_info = process.memory_info()
            return memory_info.rss / 1024 / 1024  # ƒê·ªïi t·ª´ byte sang MB
        except Exception as e:
            logger.error(f"L·ªói khi l·∫•y th√¥ng tin b·ªô nh·ªõ: {str(e)}")
            return 0.0
    
    def _get_cpu_usage(self) -> float:
        """
        L·∫•y ph·∫ßn trƒÉm CPU ƒë√£ s·ª≠ d·ª•ng
        
        Returns:
            float: Ph·∫ßn trƒÉm CPU ƒë√£ s·ª≠ d·ª•ng
        """
        try:
            import psutil
            process = psutil.Process(os.getpid())
            return process.cpu_percent(interval=0.1)
        except Exception as e:
            logger.error(f"L·ªói khi l·∫•y th√¥ng tin CPU: {str(e)}")
            return 0.0
    
    def _get_symbol_analysis(self, symbol: str) -> Dict:
        """
        L·∫•y th√¥ng tin ph√¢n t√≠ch cho m·ªôt c·∫∑p giao d·ªãch
        
        Args:
            symbol (str): K√Ω hi·ªáu c·∫∑p giao d·ªãch
            
        Returns:
            Dict: Th√¥ng tin ph√¢n t√≠ch
        """
        try:
            # Ki·ªÉm tra file recommendation
            symbol_lower = symbol.lower()
            recommendation_file = f"recommendation_{symbol_lower}.json"
            
            if os.path.exists(recommendation_file):
                with open(recommendation_file, 'r') as f:
                    return json.load(f)
            
            # N·∫øu kh√¥ng c√≥ file, tr·∫£ v·ªÅ th√¥ng tin c∆° b·∫£n
            return {
                'symbol': symbol,
                'trend': 'Kh√¥ng x√°c ƒë·ªãnh',
                'signal': 'Kh√¥ng c√≥ t√≠n hi·ªáu',
                'target_price': 'Kh√¥ng x√°c ƒë·ªãnh',
                'stop_loss': 'Kh√¥ng x√°c ƒë·ªãnh',
                'note': 'Kh√¥ng c√≥ ph√¢n t√≠ch chi ti·∫øt'
            }
        except Exception as e:
            logger.error(f"L·ªói khi l·∫•y th√¥ng tin ph√¢n t√≠ch: {str(e)}")
            return {
                'symbol': symbol,
                'trend': 'Kh√¥ng x√°c ƒë·ªãnh',
                'signal': 'Kh√¥ng c√≥ t√≠n hi·ªáu',
                'target_price': 'Kh√¥ng x√°c ƒë·ªãnh',
                'stop_loss': 'Kh√¥ng x√°c ƒë·ªãnh',
                'note': 'L·ªói khi ƒë·ªçc file ph√¢n t√≠ch'
            }
    
    def _check_notification_enabled(self, notification_type: str) -> bool:
        """
        Ki·ªÉm tra xem lo·∫°i th√¥ng b√°o c√≥ ƒë∆∞·ª£c b·∫≠t kh√¥ng
        
        Args:
            notification_type (str): Lo·∫°i th√¥ng b√°o
            
        Returns:
            bool: True n·∫øu ƒë∆∞·ª£c b·∫≠t, False n·∫øu kh√¥ng
        """
        if not self.notification_config.get('enabled', True):
            return False
            
        notification_types = self.notification_config.get('notification_types', {})
        return notification_types.get(notification_type, True)
    
    def send_all_symbol_analysis(self) -> bool:
        """
        G·ª≠i ph√¢n t√≠ch t·∫•t c·∫£ c√°c c·∫∑p giao d·ªãch
        
        Returns:
            bool: True n·∫øu th√†nh c√¥ng, False n·∫øu kh√¥ng
        """
        try:
            if not self._check_notification_enabled('system_status'):
                return False
                
            if not self._check_cooldown('system_status'):
                logger.info("B·ªè qua th√¥ng b√°o ph√¢n t√≠ch t·∫•t c·∫£ c√°c c·∫∑p do ƒëang trong th·ªùi gian ch·ªù")
                return False
                
            logger.info("ƒêang g·ª≠i th√¥ng b√°o ph√¢n t√≠ch t·∫•t c·∫£ c√°c c·∫∑p")
            
            # L·∫•y danh s√°ch c·∫∑p giao d·ªãch
            symbols = self._get_all_symbols()
            
            # Chia nh·ªè th√†nh c√°c nh√≥m ƒë·ªÉ tr√°nh th√¥ng b√°o qu√° d√†i
            max_symbols_per_message = self.notification_config.get('max_symbols_per_message', 5)
            symbol_chunks = [symbols[i:i + max_symbols_per_message] for i in range(0, len(symbols), max_symbols_per_message)]
            
            success_count = 0
            
            for chunk in symbol_chunks:
                # T·∫°o n·ªôi dung th√¥ng b√°o
                message = self._create_all_symbol_analysis_message(chunk)
                
                # G·ª≠i th√¥ng b√°o
                result = self.telegram.send_message(message, parse_mode="HTML")
                
                if result:
                    success_count += 1
                    logger.info(f"ƒê√£ g·ª≠i th√¥ng b√°o ph√¢n t√≠ch cho nh√≥m {chunk}")
                else:
                    logger.error(f"L·ªói khi g·ª≠i th√¥ng b√°o ph√¢n t√≠ch cho nh√≥m {chunk}")
                    
                # Ch·ªù m·ªôt ch√∫t ƒë·ªÉ tr√°nh spam
                time.sleep(1)
            
            if success_count == len(symbol_chunks):
                logger.info("ƒê√£ g·ª≠i th√¥ng b√°o ph√¢n t√≠ch t·∫•t c·∫£ c√°c c·∫∑p")
                return True
            else:
                logger.warning(f"Ch·ªâ g·ª≠i ƒë∆∞·ª£c {success_count}/{len(symbol_chunks)} th√¥ng b√°o ph√¢n t√≠ch")
                return False
        except Exception as e:
            logger.error(f"L·ªói khi g·ª≠i th√¥ng b√°o ph√¢n t√≠ch t·∫•t c·∫£ c√°c c·∫∑p: {str(e)}")
            return False
    
    def _create_all_symbol_analysis_message(self, symbols: List[str]) -> str:
        """
        T·∫°o n·ªôi dung th√¥ng b√°o ph√¢n t√≠ch nhi·ªÅu c·∫∑p giao d·ªãch
        
        Args:
            symbols (List[str]): Danh s√°ch c·∫∑p giao d·ªãch
            
        Returns:
            str: N·ªôi dung th√¥ng b√°o
        """
        try:
            # T·∫°o th√¥ng b√°o
            message = "üìä <b>PH√ÇN T√çCH NHI·ªÄU C·∫∂P GIAO D·ªäCH</b>\n\n"
            
            for symbol in symbols:
                # L·∫•y th√¥ng tin ph√¢n t√≠ch
                analysis = self._get_symbol_analysis(symbol)
                
                # L·∫•y gi√° hi·ªán t·∫°i
                current_price = self.market_data.get(symbol, 0)
                
                # X√°c ƒë·ªãnh bi·ªÉu t∆∞·ª£ng d·ª±a tr√™n t√≠n hi·ªáu
                signal = analysis.get('signal', 'NEUTRAL')
                if signal in ["BUY", "STRONG_BUY"]:
                    signal_emoji = "üü¢"
                elif signal in ["SELL", "STRONG_SELL"]:
                    signal_emoji = "üî¥"
                else:
                    signal_emoji = "‚ö™"
                
                # Th√™m th√¥ng tin cho c·∫∑p giao d·ªãch n√†y
                message += f"{signal_emoji} <b>{symbol}</b>\n"
                message += f"üíµ Gi√°: {current_price:.4f}\n"
                message += f"üìä Xu h∆∞·ªõng: {analysis.get('trend', 'Kh√¥ng x√°c ƒë·ªãnh')}\n"
                message += f"üîç T√≠n hi·ªáu: {analysis.get('signal', 'Kh√¥ng c√≥ t√≠n hi·ªáu')}\n"
                
                # Th√™m m·ª•c ti√™u v√† stop loss n·∫øu c√≥
                target_price = analysis.get('target_price', None)
                stop_loss = analysis.get('stop_loss', None)
                
                if target_price and target_price != 'Kh√¥ng x√°c ƒë·ªãnh':
                    message += f"üéØ M·ª•c ti√™u: {target_price}\n"
                    
                if stop_loss and stop_loss != 'Kh√¥ng x√°c ƒë·ªãnh':
                    message += f"üõë Stop Loss: {stop_loss}\n"
                
                # Th√™m ghi ch√∫ n·∫øu c√≥
                note = analysis.get('note', None)
                if note and note != 'Kh√¥ng c√≥ ph√¢n t√≠ch chi ti·∫øt':
                    message += f"üìù Ghi ch√∫: {note}\n"
                
                message += "\n"
            
            # Th√™m th√¥ng tin th·ªùi gian
            message += f"<i>‚è±Ô∏è {datetime.datetime.now().strftime('%H:%M:%S %d/%m/%Y')}</i>"
            
            return message
        except Exception as e:
            logger.error(f"L·ªói khi t·∫°o th√¥ng b√°o ph√¢n t√≠ch nhi·ªÅu c·∫∑p: {str(e)}")
            return f"<b>üìä PH√ÇN T√çCH NHI·ªÄU C·∫∂P GIAO D·ªäCH</b>\n\nKh√¥ng th·ªÉ t·∫°o ph√¢n t√≠ch chi ti·∫øt cho: {', '.join(symbols)}"
    
    def _get_all_symbols(self) -> List[str]:
        """
        L·∫•y danh s√°ch t·∫•t c·∫£ c√°c c·∫∑p giao d·ªãch t·ª´ file c·∫•u h√¨nh
        
        Returns:
            List[str]: Danh s√°ch c√°c c·∫∑p giao d·ªãch
        """
        try:
            # Th·ª≠ ƒë·ªçc t·ª´ bot_config.json
            if os.path.exists('bot_config.json'):
                with open('bot_config.json', 'r') as f:
                    config = json.load(f)
                    if 'symbols' in config:
                        return config['symbols']
            
            # Th·ª≠ ƒë·ªçc t·ª´ account_config.json
            if os.path.exists('account_config.json'):
                with open('account_config.json', 'r') as f:
                    config = json.load(f)
                    if 'symbols' in config:
                        return config['symbols']
            
            # Danh s√°ch m·∫∑c ƒë·ªãnh ƒë∆∞·ª£c h·ªó tr·ª£ b·ªüi Binance Testnet
            return [
                "BTCUSDT", "ETHUSDT", "BNBUSDT", "SOLUSDT", "ADAUSDT", 
                "XRPUSDT", "DOGEUSDT", "DOTUSDT", "AVAXUSDT", 
                "LINKUSDT", "LTCUSDT", "UNIUSDT", "ATOMUSDT"
            ]
        except Exception as e:
            logger.error(f"L·ªói khi l·∫•y danh s√°ch c·∫∑p giao d·ªãch: {str(e)}")
            # Danh s√°ch c∆° b·∫£n n·∫øu c√≥ l·ªói
            return [
                "BTCUSDT", "ETHUSDT", "BNBUSDT", "SOLUSDT", "ADAUSDT"
            ]
            
    def notify_entry(self, entry_data: Dict) -> bool:
        """
        G·ª≠i th√¥ng b√°o khi v√†o l·ªánh
        
        Args:
            entry_data (Dict): Th√¥ng tin l·ªánh v√†o
            
        Returns:
            bool: True n·∫øu th√†nh c√¥ng, False n·∫øu kh√¥ng
        """
        try:
            if not self._check_notification_enabled('trade_signal'):
                return False
                
            logger.info(f"ƒêang g·ª≠i th√¥ng b√°o v√†o l·ªánh cho {entry_data.get('symbol', 'Unknown')}")
            
            # T·∫°o th√¥ng b√°o d·ª±a tr√™n d·ªØ li·ªáu v√†o l·ªánh
            symbol = entry_data.get('symbol', 'Unknown')
            side = entry_data.get('side', 'LONG')
            entry_price = entry_data.get('entry_price', 0)
            quantity = entry_data.get('quantity', 0)
            leverage = entry_data.get('leverage', 1)
            take_profit = entry_data.get('take_profit', 0)
            stop_loss = entry_data.get('stop_loss', 0)
            entry_reason = entry_data.get('entry_reason', 'T√≠n hi·ªáu k·ªπ thu·∫≠t')
            
            # X√°c ƒë·ªãnh lo·∫°i l·ªánh v√† emoji
            emoji = "üü¢" if side == "LONG" else "üî¥"
            
            # T·∫°o n·ªôi dung th√¥ng b√°o
            message = f"{emoji} <b>V√ÄO L·ªÜNH - {symbol} {side}</b> {emoji}\n\n"
            message += f"üí∞ <b>Gi√° v√†o:</b> {entry_price:.4f}\n"
            message += f"üìä <b>S·ªë l∆∞·ª£ng:</b> {abs(quantity):.4f}\n"
            message += f"üîÑ <b>ƒê√≤n b·∫©y:</b> {leverage}x\n"
            message += f"üéØ <b>Take Profit:</b> {take_profit:.4f}\n"
            message += f"üõë <b>Stop Loss:</b> {stop_loss:.4f}\n"
            message += f"üìù <b>L√Ω do v√†o l·ªánh:</b> {entry_reason}\n\n"
            
            # Th√™m ph√¢n t√≠ch n·∫øu c√≥
            analysis = self._get_symbol_analysis(symbol)
            if analysis:
                message += "<b>PH√ÇN T√çCH K·ª∏ THU·∫¨T</b>\n"
                message += f"üìä <b>Xu h∆∞·ªõng:</b> {analysis.get('trend', 'N/A')}\n"
                message += f"üîç <b>T√≠n hi·ªáu:</b> {analysis.get('signal', 'N/A')}\n"
                message += f"üìà <b>Risk/Reward:</b> {entry_data.get('risk_reward_ratio', 'N/A'):.2f}\n\n"
            
            # Th√™m th√¥ng tin th·ªùi gian
            message += f"<i>‚è±Ô∏è {datetime.datetime.now().strftime('%H:%M:%S %d/%m/%Y')}</i>"
            
            # G·ª≠i th√¥ng b√°o
            result = self.telegram.send_message(message, parse_mode="HTML")
            
            if result:
                logger.info(f"ƒê√£ g·ª≠i th√¥ng b√°o v√†o l·ªánh cho {symbol}")
                
                # L∆∞u v·ªã th·∫ø v√†o c√°c v·ªã th·∫ø ƒëang m·ªü
                position_data = {
                    'symbol': symbol,
                    'side': side,
                    'entry_price': entry_price,
                    'quantity': quantity,
                    'leverage': leverage,
                    'take_profit': take_profit,
                    'stop_loss': stop_loss,
                    'entry_time': datetime.datetime.now().isoformat(),
                    'entry_reason': entry_reason
                }
                self.active_positions[symbol] = position_data
                
                return True
            else:
                logger.error(f"L·ªói khi g·ª≠i th√¥ng b√°o v√†o l·ªánh cho {symbol}")
                return False
        except Exception as e:
            logger.error(f"L·ªói khi x·ª≠ l√Ω th√¥ng b√°o v√†o l·ªánh: {str(e)}")
            return False
    
    def notify_exit(self, exit_data: Dict) -> bool:
        """
        G·ª≠i th√¥ng b√°o khi ra l·ªánh
        
        Args:
            exit_data (Dict): Th√¥ng tin l·ªánh ra
            
        Returns:
            bool: True n·∫øu th√†nh c√¥ng, False n·∫øu kh√¥ng
        """
        try:
            if not self._check_notification_enabled('trade_signal'):
                return False
                
            logger.info(f"ƒêang g·ª≠i th√¥ng b√°o ra l·ªánh cho {exit_data.get('symbol', 'Unknown')}")
            
            # T·∫°o th√¥ng b√°o d·ª±a tr√™n d·ªØ li·ªáu ra l·ªánh
            symbol = exit_data.get('symbol', 'Unknown')
            side = exit_data.get('side', 'LONG')
            entry_price = exit_data.get('entry_price', 0)
            exit_price = exit_data.get('exit_price', 0)
            quantity = exit_data.get('quantity', 0)
            profit_loss = exit_data.get('profit_loss', 0)
            profit_loss_percent = exit_data.get('profit_loss_percent', 0)
            holding_time = exit_data.get('holding_time', 'N/A')
            exit_reason = exit_data.get('exit_reason', 'T√≠n hi·ªáu tho√°t l·ªánh')
            
            # X√°c ƒë·ªãnh lo·∫°i l·ªánh v√† emoji
            is_profit = profit_loss > 0
            result_emoji = "‚úÖ" if is_profit else "‚ùå"
            result_text = "TH√ÄNH C√îNG" if is_profit else "L·ªñ"
            side_emoji = "üü¢" if side == "LONG" else "üî¥"
            
            # T·∫°o n·ªôi dung th√¥ng b√°o
            message = f"{result_emoji} <b>RA L·ªÜNH {result_text} - {symbol} {side}</b> {side_emoji}\n\n"
            
            message += "<b>CHI TI·∫æT GIAO D·ªäCH</b>\n"
            message += f"üí∞ <b>Gi√° v√†o:</b> {entry_price:.4f}\n"
            message += f"üíµ <b>Gi√° ra:</b> {exit_price:.4f}\n"
            message += f"üìä <b>S·ªë l∆∞·ª£ng:</b> {abs(quantity):.4f}\n"
            
            # Th√™m th√¥ng tin l·ª£i nhu·∫≠n
            if is_profit:
                message += f"üìà <b>L·ª£i nhu·∫≠n:</b> +{profit_loss:.2f} USDT (+{profit_loss_percent:.2f}%)\n"
            else:
                message += f"üìâ <b>L·ª£i nhu·∫≠n:</b> {profit_loss:.2f} USDT ({profit_loss_percent:.2f}%)\n"
                
            message += f"‚è±Ô∏è <b>Th·ªùi gian gi·ªØ:</b> {holding_time}\n"
            message += f"üìù <b>L√Ω do ra l·ªánh:</b> {exit_reason}\n\n"
            
            # Th√™m ph√¢n t√≠ch th·ªã tr∆∞·ªùng hi·ªán t·∫°i
            analysis = self._get_symbol_analysis(symbol)
            if analysis:
                message += "<b>PH√ÇN T√çCH TH·ªä TR∆Ø·ªúNG HI·ªÜN T·∫†I</b>\n"
                message += f"üìä <b>Xu h∆∞·ªõng:</b> {analysis.get('trend', 'N/A')}\n"
                message += f"üîç <b>T√≠n hi·ªáu:</b> {analysis.get('signal', 'N/A')}\n"
                message += f"üìù <b>Ghi ch√∫:</b> {analysis.get('note', 'N/A')}\n\n"
            
            # Th√™m th√¥ng tin th·ªùi gian
            message += f"<i>‚è±Ô∏è {datetime.datetime.now().strftime('%H:%M:%S %d/%m/%Y')}</i>"
            
            # G·ª≠i th√¥ng b√°o
            result = self.telegram.send_message(message, parse_mode="HTML")
            
            if result:
                logger.info(f"ƒê√£ g·ª≠i th√¥ng b√°o ra l·ªánh cho {symbol}")
                
                # X√≥a v·ªã th·∫ø kh·ªèi c√°c v·ªã th·∫ø ƒëang m·ªü
                if symbol in self.active_positions:
                    del self.active_positions[symbol]
                
                return True
            else:
                logger.error(f"L·ªói khi g·ª≠i th√¥ng b√°o ra l·ªánh cho {symbol}")
                return False
        except Exception as e:
            logger.error(f"L·ªói khi x·ª≠ l√Ω th√¥ng b√°o ra l·ªánh: {str(e)}")
            return False
            
    def notify_market_analysis(self, analysis_data: Dict) -> bool:
        """
        G·ª≠i th√¥ng b√°o ph√¢n t√≠ch th·ªã tr∆∞·ªùng
        
        Args:
            analysis_data (Dict): D·ªØ li·ªáu ph√¢n t√≠ch th·ªã tr∆∞·ªùng
            
        Returns:
            bool: True n·∫øu th√†nh c√¥ng, False n·∫øu kh√¥ng
        """
        try:
            if not self._check_notification_enabled('market_alert'):
                return False
                
            if not self._check_cooldown('market_alert'):
                return False
            
            symbol = analysis_data.get('symbol', 'Unknown')
            logger.info(f"ƒêang g·ª≠i th√¥ng b√°o ph√¢n t√≠ch th·ªã tr∆∞·ªùng cho {symbol}")
            
            # T·∫°o th√¥ng b√°o d·ª±a tr√™n d·ªØ li·ªáu ph√¢n t√≠ch
            trend = analysis_data.get('trend', 'NEUTRAL')
            signal = analysis_data.get('signal', 'NEUTRAL')
            price = analysis_data.get('price', 0)
            
            # X√°c ƒë·ªãnh bi·ªÉu t∆∞·ª£ng d·ª±a tr√™n t√≠n hi·ªáu
            if signal in ["BUY", "STRONG_BUY"]:
                signal_emoji = "üü¢"
                signal_text = "MUA" if signal == "BUY" else "MUA M·∫†NH"
            elif signal in ["SELL", "STRONG_SELL"]:
                signal_emoji = "üî¥"
                signal_text = "B√ÅN" if signal == "SELL" else "B√ÅN M·∫†NH"
            else:
                signal_emoji = "‚ö™"
                signal_text = "TRUNG L·∫¨P"
            
            # T·∫°o n·ªôi dung th√¥ng b√°o
            message = f"{signal_emoji} <b>PH√ÇN T√çCH TH·ªä TR∆Ø·ªúNG - {symbol}</b>\n\n"
            
            message += f"üíµ <b>Gi√° hi·ªán t·∫°i:</b> {price:.4f}\n"
            message += f"üìä <b>Xu h∆∞·ªõng:</b> {trend}\n"
            message += f"üîç <b>T√≠n hi·ªáu:</b> {signal_text}\n\n"
            
            # Th√™m chi ti·∫øt ch·ªâ b√°o n·∫øu c√≥
            indicators = analysis_data.get('indicators', {})
            if indicators:
                message += "<b>CH·ªà B√ÅO K·ª∏ THU·∫¨T</b>\n"
                
                if 'rsi' in indicators:
                    rsi = indicators['rsi']
                    rsi_status = "Qu√° b√°n (<30)" if rsi < 30 else "Qu√° mua (>70)" if rsi > 70 else "Trung t√≠nh"
                    message += f"üìâ <b>RSI:</b> {rsi:.2f} - {rsi_status}\n"
                
                if 'macd' in indicators:
                    macd = indicators['macd']
                    macd_signal = indicators.get('macd_signal', 0)
                    macd_status = "T√≠ch c·ª±c" if macd > macd_signal else "Ti√™u c·ª±c"
                    message += f"üìä <b>MACD:</b> {macd:.2f} - {macd_status}\n"
                
                if 'ema50' in indicators and 'ema200' in indicators:
                    ema50 = indicators['ema50']
                    ema200 = indicators['ema200']
                    ema_status = "Xu h∆∞·ªõng tƒÉng" if ema50 > ema200 else "Xu h∆∞·ªõng gi·∫£m"
                    message += f"üìà <b>EMA50/200:</b> {ema_status}\n"
                
                if 'bb_upper' in indicators and 'bb_lower' in indicators:
                    bb_upper = indicators['bb_upper']
                    bb_lower = indicators['bb_lower']
                    bb_width = (bb_upper - bb_lower) / price * 100
                    message += f"üìè <b>BB Width:</b> {bb_width:.2f}%\n\n"
            
            # Th√™m khuy·∫øn ngh·ªã n·∫øu c√≥
            recommendation = analysis_data.get('recommendation', {})
            if recommendation:
                message += "<b>KHUY·∫æN NGH·ªä</b>\n"
                
                action = recommendation.get('action', 'WAIT')
                reason = recommendation.get('reason', 'Ch·ªù ƒë·ª£i t√≠n hi·ªáu r√µ r√†ng h∆°n')
                target = recommendation.get('target', 'N/A')
                stop = recommendation.get('stop', 'N/A')
                
                message += f"üéØ <b>H√†nh ƒë·ªông:</b> {action}\n"
                message += f"üìù <b>L√Ω do:</b> {reason}\n"
                
                if target != 'N/A':
                    message += f"üíπ <b>M·ª•c ti√™u:</b> {target}\n"
                
                if stop != 'N/A':
                    message += f"üõë <b>Stop:</b> {stop}\n\n"
            
            # Th√™m th√¥ng tin c√°c v·ªã th·∫ø ƒëang m·ªü cho c·∫∑p n√†y n·∫øu c√≥
            if symbol in self.active_positions:
                position = self.active_positions[symbol]
                side = position.get('side', 'LONG')
                entry_price = position.get('entry_price', 0)
                side_emoji = "üü¢" if side == "LONG" else "üî¥"
                
                message += f"{side_emoji} <b>V·ªä TH·∫æ ƒêANG M·ªû</b>\n"
                message += f"‚öôÔ∏è <b>Lo·∫°i:</b> {side}\n"
                message += f"üí∞ <b>Gi√° v√†o:</b> {entry_price:.4f}\n"
                
                # T√≠nh l·ª£i nhu·∫≠n
                current_profit = 0
                if side == "LONG":
                    current_profit = (price - entry_price) / entry_price * 100
                else:
                    current_profit = (entry_price - price) / entry_price * 100
                
                profit_emoji = "üìà" if current_profit > 0 else "üìâ"
                message += f"{profit_emoji} <b>P/L Hi·ªán t·∫°i:</b> {current_profit:.2f}%\n\n"
            
            # Th√™m th√¥ng tin th·ªùi gian
            message += f"<i>‚è±Ô∏è {datetime.datetime.now().strftime('%H:%M:%S %d/%m/%Y')}</i>"
            
            # G·ª≠i th√¥ng b√°o
            result = self.telegram.send_message(message, parse_mode="HTML")
            
            if result:
                logger.info(f"ƒê√£ g·ª≠i th√¥ng b√°o ph√¢n t√≠ch th·ªã tr∆∞·ªùng cho {symbol}")
                return True
            else:
                logger.error(f"L·ªói khi g·ª≠i th√¥ng b√°o ph√¢n t√≠ch th·ªã tr∆∞·ªùng cho {symbol}")
                return False
        except Exception as e:
            logger.error(f"L·ªói khi x·ª≠ l√Ω th√¥ng b√°o ph√¢n t√≠ch th·ªã tr∆∞·ªùng: {str(e)}")
            return False


if __name__ == "__main__":
    # Test module
    try:
        notifier = DetailedTradeNotifications()
        
        # G·ª≠i th√¥ng b√°o tr·∫°ng th√°i h·ªá th·ªëng
        notifier.send_system_status()
        
        # G·ª≠i ph√¢n t√≠ch t·∫•t c·∫£ c√°c c·∫∑p
        notifier.send_all_symbol_analysis()
        
        logger.info("ƒê√£ g·ª≠i c√°c th√¥ng b√°o test")
    except Exception as e:
        logger.error(f"L·ªói khi ch·∫°y module test: {str(e)}")
        logger.error(traceback.format_exc())