"""
H·ªá th·ªëng th√¥ng b√°o th·ªã tr∆∞·ªùng t·ª± ƒë·ªông
Module n√†y s·∫Ω t·ª± ƒë·ªông g·ª≠i th√¥ng b√°o ph√¢n t√≠ch th·ªã tr∆∞·ªùng theo l·ªãch tr√¨nh cho c√°c c·∫∑p ti·ªÅn ƒëi·ªán t·ª≠
"""
import time
import logging
import threading
import schedule
import json
import os
from datetime import datetime, timedelta
import random

# Import c√°c module th√¥ng b√°o c·ªßa h·ªá th·ªëng
from detailed_trade_notifications import DetailedTradeNotifications
from telegram_notifier import TelegramNotifier
from market_analysis_system import MarketAnalysisSystem

# Thi·∫øt l·∫≠p logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger('auto_market_notifier')

class AutoMarketNotifier:
    """L·ªõp qu·∫£n l√Ω th√¥ng b√°o th·ªã tr∆∞·ªùng t·ª± ƒë·ªông theo l·ªãch tr√¨nh"""
    
    def __init__(self):
        """Kh·ªüi t·∫°o h·ªá th·ªëng th√¥ng b√°o th·ªã tr∆∞·ªùng t·ª± ƒë·ªông"""
        self.notifier = DetailedTradeNotifications()
        self.market_analyzer = MarketAnalysisSystem()
        self.telegram = TelegramNotifier()
        self.active = False
        self.thread = None
        self.monitored_coins = self._load_monitored_coins()
        self.last_notification_time = {}
        
        # T·∫°o th∆∞ m·ª•c logs n·∫øu ch∆∞a t·ªìn t·∫°i
        os.makedirs('logs', exist_ok=True)
        
        logger.info(f"Kh·ªüi t·∫°o Auto Market Notifier v·ªõi {len(self.monitored_coins)} c·∫∑p ti·ªÅn ƒëi·ªán t·ª≠")
        
    def _load_monitored_coins(self):
        """T·∫£i danh s√°ch c√°c c·∫∑p ti·ªÅn ƒëi·ªán t·ª≠ ƒë∆∞·ª£c theo d√µi t·ª´ c·∫•u h√¨nh"""
        try:
            # Th·ª≠ t·∫£i t·ª´ account_config.json
            with open('account_config.json', 'r') as f:
                config = json.load(f)
                if 'monitored_symbols' in config:
                    return config['monitored_symbols']
            
            # M·∫∑c ƒë·ªãnh n·∫øu kh√¥ng t√¨m th·∫•y
            return [
                "BTCUSDT", "ETHUSDT", "BNBUSDT", "SOLUSDT", "ADAUSDT", 
                "DOGEUSDT", "MATICUSDT", "LINKUSDT", "DOTUSDT", "LTCUSDT",
                "AVAXUSDT", "XRPUSDT", "NEARUSDT"
            ]
        except Exception as e:
            logger.error(f"L·ªói khi t·∫£i danh s√°ch c·∫∑p ti·ªÅn ƒëi·ªán t·ª≠: {e}")
            # Tr·∫£ v·ªÅ danh s√°ch m·∫∑c ƒë·ªãnh
            return ["BTCUSDT", "ETHUSDT", "BNBUSDT", "SOLUSDT"]
    
    def send_single_coin_analysis(self, symbol):
        """G·ª≠i ph√¢n t√≠ch cho m·ªôt c·∫∑p ti·ªÅn ƒëi·ªán t·ª≠"""
        try:
            logger.info(f"ƒêang g·ª≠i ph√¢n t√≠ch th·ªã tr∆∞·ªùng cho {symbol}")
            # T·∫°o ph√¢n t√≠ch th·ªã tr∆∞·ªùng
            analysis = self.market_analyzer.analyze_symbol(symbol)
            if analysis:
                # G·ª≠i th√¥ng b√°o
                self.notifier.notify_market_analysis(analysis)
                # C·∫≠p nh·∫≠t th·ªùi gian th√¥ng b√°o cu·ªëi c√πng
                self.last_notification_time[symbol] = datetime.now()
                logger.info(f"ƒê√£ g·ª≠i ph√¢n t√≠ch th·ªã tr∆∞·ªùng th√†nh c√¥ng cho {symbol}")
                return True
            else:
                logger.warning(f"Kh√¥ng th·ªÉ t·∫°o ph√¢n t√≠ch th·ªã tr∆∞·ªùng cho {symbol}")
                return False
        except Exception as e:
            logger.error(f"L·ªói khi g·ª≠i ph√¢n t√≠ch th·ªã tr∆∞·ªùng cho {symbol}: {e}")
            return False

    def send_multi_coin_analysis(self):
        """G·ª≠i ph√¢n t√≠ch ƒëa c·∫∑p ti·ªÅn ƒëi·ªán t·ª≠"""
        try:
            # L·∫•y ng·∫´u nhi√™n 4-5 c·∫∑p ti·ªÅn ƒëi·ªán t·ª≠ ƒë·ªÉ ph√¢n t√≠ch
            num_coins = min(len(self.monitored_coins), random.randint(4, 5))
            selected_coins = random.sample(self.monitored_coins, num_coins)
            
            logger.info(f"ƒêang g·ª≠i ph√¢n t√≠ch ƒëa c·∫∑p ti·ªÅn ƒëi·ªán t·ª≠: {selected_coins}")
            self.notifier.send_multi_symbol_analysis(selected_coins)
            logger.info(f"ƒê√£ g·ª≠i ph√¢n t√≠ch ƒëa c·∫∑p ti·ªÅn ƒëi·ªán t·ª≠ th√†nh c√¥ng")
            return True
        except Exception as e:
            logger.error(f"L·ªói khi g·ª≠i ph√¢n t√≠ch ƒëa c·∫∑p ti·ªÅn ƒëi·ªán t·ª≠: {e}")
            return False
    
    def send_no_trade_reasons(self, symbol):
        """G·ª≠i l√Ω do kh√¥ng giao d·ªãch cho m·ªôt c·∫∑p ti·ªÅn ƒëi·ªán t·ª≠"""
        try:
            logger.info(f"ƒêang g·ª≠i l√Ω do kh√¥ng giao d·ªãch cho {symbol}")
            self.notifier.send_no_trade_reasons(symbol)
            logger.info(f"ƒê√£ g·ª≠i l√Ω do kh√¥ng giao d·ªãch th√†nh c√¥ng cho {symbol}")
            return True
        except Exception as e:
            logger.error(f"L·ªói khi g·ª≠i l√Ω do kh√¥ng giao d·ªãch cho {symbol}: {e}")
            return False
    
    def send_important_market_update(self):
        """G·ª≠i c·∫≠p nh·∫≠t quan tr·ªçng v·ªÅ th·ªã tr∆∞·ªùng"""
        try:
            # L·∫•y c·∫∑p BTC l√†m chu·∫©n cho ph√¢n t√≠ch th·ªã tr∆∞·ªùng t·ªïng th·ªÉ
            logger.info("ƒêang g·ª≠i c·∫≠p nh·∫≠t quan tr·ªçng v·ªÅ th·ªã tr∆∞·ªùng")
            
            # Th·ª±c hi·ªán ph√¢n t√≠ch th·ªã tr∆∞·ªùng t·ªïng th·ªÉ
            market_state = self.market_analyzer.get_market_regime()
            
            # T·∫°o th√¥ng b√°o
            message = f"üîé *PH√ÇN T√çCH TH·ªä TR∆Ø·ªúNG T·ªîNG TH·ªÇ*\n\n"
            message += f"‚è∞ *Th·ªùi gian*: {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}\n\n"
            message += f"üìä *Tr·∫°ng th√°i th·ªã tr∆∞·ªùng*: {market_state['regime']}\n"
            message += f"üìà *ƒê·ªô bi·∫øn ƒë·ªông*: {market_state['volatility']:.2f}%\n"
            message += f"üßÆ *Ch·ªâ s·ªë th·ªã tr∆∞·ªùng*: {market_state['market_score']:.2f}/100\n\n"
            message += f"üí° *G·ª£i √Ω*: {market_state['recommendation']}\n\n"
            message += f"_ƒê√¢y l√† th√¥ng b√°o t·ª± ƒë·ªông t·ª´ h·ªá th·ªëng Auto Market Notifier_"
            
            # G·ª≠i th√¥ng b√°o
            self.telegram.send_message(message)
            logger.info("ƒê√£ g·ª≠i c·∫≠p nh·∫≠t quan tr·ªçng v·ªÅ th·ªã tr∆∞·ªùng th√†nh c√¥ng")
            return True
        except Exception as e:
            logger.error(f"L·ªói khi g·ª≠i c·∫≠p nh·∫≠t quan tr·ªçng v·ªÅ th·ªã tr∆∞·ªùng: {e}")
            return False
    
    def _schedule_jobs(self):
        """L·∫≠p l·ªãch c√°c c√¥ng vi·ªác th√¥ng b√°o t·ª± ƒë·ªông"""
        # X√≥a t·∫•t c·∫£ c√°c c√¥ng vi·ªác ƒë√£ l·∫≠p l·ªãch tr∆∞·ªõc ƒë√≥
        schedule.clear()
        
        # L·∫≠p l·ªãch g·ª≠i ph√¢n t√≠ch ƒë∆°n c·∫∑p ti·ªÅn ƒëi·ªán t·ª≠ (m·ªói 2 gi·ªù)
        for symbol in self.monitored_coins:
            # Ph√¢n b·ªï ng·∫´u nhi√™n th·ªùi gian ƒë·ªÉ tr√°nh g·ª≠i c√πng l√∫c t·∫•t c·∫£ c√°c th√¥ng b√°o
            hour = random.randint(0, 23)
            minute = random.randint(0, 59)
            schedule.every().day.at(f"{hour:02d}:{minute:02d}").do(self.send_single_coin_analysis, symbol=symbol)
            logger.info(f"ƒê√£ l·∫≠p l·ªãch ph√¢n t√≠ch h√†ng ng√†y cho {symbol} v√†o l√∫c {hour:02d}:{minute:02d}")
        
        # L·∫≠p l·ªãch g·ª≠i ph√¢n t√≠ch ƒëa c·∫∑p ti·ªÅn ƒëi·ªán t·ª≠ (4 l·∫ßn m·ªói ng√†y)
        for hour in [6, 12, 18, 23]:
            minute = random.randint(0, 59)
            schedule.every().day.at(f"{hour:02d}:{minute:02d}").do(self.send_multi_coin_analysis)
            logger.info(f"ƒê√£ l·∫≠p l·ªãch ph√¢n t√≠ch ƒëa c·∫∑p ti·ªÅn ƒëi·ªán t·ª≠ v√†o l√∫c {hour:02d}:{minute:02d}")
        
        # L·∫≠p l·ªãch g·ª≠i c·∫≠p nh·∫≠t quan tr·ªçng v·ªÅ th·ªã tr∆∞·ªùng (2 l·∫ßn m·ªói ng√†y)
        schedule.every().day.at("08:30").do(self.send_important_market_update)
        schedule.every().day.at("20:30").do(self.send_important_market_update)
        logger.info("ƒê√£ l·∫≠p l·ªãch c·∫≠p nh·∫≠t quan tr·ªçng v·ªÅ th·ªã tr∆∞·ªùng v√†o l√∫c 08:30 v√† 20:30")
        
        # L·∫≠p l·ªãch ng·∫´u nhi√™n ƒë·ªÉ g·ª≠i l√Ω do kh√¥ng giao d·ªãch
        for symbol in self.monitored_coins[:4]:  # Ch·ªâ l·∫•y 4 c·∫∑p ƒë·∫ßu ti√™n
            hour = random.randint(0, 23)
            minute = random.randint(0, 59)
            schedule.every().day.at(f"{hour:02d}:{minute:02d}").do(self.send_no_trade_reasons, symbol=symbol)
            logger.info(f"ƒê√£ l·∫≠p l·ªãch g·ª≠i l√Ω do kh√¥ng giao d·ªãch cho {symbol} v√†o l√∫c {hour:02d}:{minute:02d}")
        
        # Th√™m m·ªôt s·ªë th√¥ng b√°o m·ªói v√†i gi·ªù cho c√°c tr∆∞·ªùng h·ª£p c·∫ßn thi·∫øt
        schedule.every(4).hours.do(self.send_single_coin_analysis, symbol="BTCUSDT")
        schedule.every(6).hours.do(self.send_single_coin_analysis, symbol="ETHUSDT")
        
        logger.info("ƒê√£ c·∫•u h√¨nh t·∫•t c·∫£ c√°c l·ªãch tr√¨nh th√¥ng b√°o t·ª± ƒë·ªông")
    
    def _run_scheduler(self):
        """Ch·∫°y b·ªô l·∫≠p l·ªãch trong m·ªôt v√≤ng l·∫∑p v√¥ h·∫°n"""
        logger.info("B·∫Øt ƒë·∫ßu b·ªô l·∫≠p l·ªãch th√¥ng b√°o t·ª± ƒë·ªông")
        self._schedule_jobs()
        
        # L·∫≠p l·ªãch l·∫°i m·ªói ng√†y ƒë·ªÉ ƒë·∫£m b·∫£o c·∫≠p nh·∫≠t
        last_reschedule_date = datetime.now().date()
        
        while self.active:
            try:
                # Ki·ªÉm tra v√† ch·∫°y c√°c c√¥ng vi·ªác theo l·ªãch
                schedule.run_pending()
                
                # L·∫≠p l·ªãch l·∫°i m·ªói ng√†y ƒë·ªÉ c·∫≠p nh·∫≠t ng·∫´u nhi√™n th·ªùi gian th√¥ng b√°o
                current_date = datetime.now().date()
                if current_date > last_reschedule_date:
                    logger.info("L·∫≠p l·ªãch l·∫°i c√°c c√¥ng vi·ªác th√¥ng b√°o t·ª± ƒë·ªông")
                    self._schedule_jobs()
                    last_reschedule_date = current_date
                
                # Ng·ªß 10 gi√¢y tr∆∞·ªõc khi ki·ªÉm tra l·∫°i
                time.sleep(10)
            except Exception as e:
                logger.error(f"L·ªói trong b·ªô l·∫≠p l·ªãch: {e}")
                time.sleep(60)  # T·∫°m d·ª´ng 1 ph√∫t n·∫øu c√≥ l·ªói
    
    def start(self):
        """B·∫Øt ƒë·∫ßu h·ªá th·ªëng th√¥ng b√°o t·ª± ƒë·ªông"""
        if not self.active:
            self.active = True
            # Kh·ªüi t·∫°o v√† b·∫Øt ƒë·∫ßu thread
            self.thread = threading.Thread(target=self._run_scheduler)
            self.thread.daemon = True
            self.thread.start()
            logger.info("ƒê√£ b·∫Øt ƒë·∫ßu h·ªá th·ªëng th√¥ng b√°o th·ªã tr∆∞·ªùng t·ª± ƒë·ªông")
            
            # G·ª≠i th√¥ng b√°o v·ªÅ vi·ªác kh·ªüi ƒë·ªông h·ªá th·ªëng
            startup_message = (
                "ü§ñ *H·ªÜ TH·ªêNG TH√îNG B√ÅO T·ª∞ ƒê·ªòNG ƒê√É KH·ªûI ƒê·ªòNG*\n\n"
                f"Th·ªùi gian: {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}\n"
                f"Coins ƒë∆∞·ª£c theo d√µi: {len(self.monitored_coins)} c·∫∑p\n"
                "C√°c lo·∫°i th√¥ng b√°o:\n"
                "‚úì Ph√¢n t√≠ch ƒë∆°n c·∫∑p ti·ªÅn\n"
                "‚úì Ph√¢n t√≠ch ƒëa c·∫∑p ti·ªÅn\n"
                "‚úì C·∫≠p nh·∫≠t tr·∫°ng th√°i th·ªã tr∆∞·ªùng\n"
                "‚úì L√Ω do kh√¥ng giao d·ªãch\n\n"
                "_H·ªá th·ªëng s·∫Ω t·ª± ƒë·ªông g·ª≠i th√¥ng b√°o theo l·ªãch tr√¨nh_"
            )
            try:
                self.telegram.send_message(startup_message)
            except Exception as e:
                logger.warning(f"Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o kh·ªüi ƒë·ªông: {e}")
            
            return True
        else:
            logger.warning("H·ªá th·ªëng th√¥ng b√°o t·ª± ƒë·ªông ƒë√£ ƒë∆∞·ª£c kh·ªüi ƒë·ªông tr∆∞·ªõc ƒë√≥")
            return False
    
    def stop(self):
        """D·ª´ng h·ªá th·ªëng th√¥ng b√°o t·ª± ƒë·ªông"""
        if self.active:
            self.active = False
            # Ch·ªù thread k·∫øt th√∫c
            if self.thread:
                self.thread.join(timeout=2.0)
            logger.info("ƒê√£ d·ª´ng h·ªá th·ªëng th√¥ng b√°o th·ªã tr∆∞·ªùng t·ª± ƒë·ªông")
            
            # G·ª≠i th√¥ng b√°o v·ªÅ vi·ªác d·ª´ng h·ªá th·ªëng
            try:
                shutdown_message = (
                    "üõë *H·ªÜ TH·ªêNG TH√îNG B√ÅO T·ª∞ ƒê·ªòNG ƒê√É D·ª™NG*\n\n"
                    f"Th·ªùi gian: {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}\n"
                    "_H·ªá th·ªëng s·∫Ω kh√¥ng g·ª≠i th√¥ng b√°o t·ª± ƒë·ªông cho ƒë·∫øn khi ƒë∆∞·ª£c kh·ªüi ƒë·ªông l·∫°i_"
                )
                self.telegram.send_message(shutdown_message)
            except Exception as e:
                logger.warning(f"Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o d·ª´ng: {e}")
            
            return True
        else:
            logger.warning("H·ªá th·ªëng th√¥ng b√°o t·ª± ƒë·ªông ch∆∞a ƒë∆∞·ª£c kh·ªüi ƒë·ªông")
            return False
    
    def is_running(self):
        """Ki·ªÉm tra xem h·ªá th·ªëng th√¥ng b√°o t·ª± ƒë·ªông c√≥ ƒëang ch·∫°y hay kh√¥ng"""
        return self.active
    
    def get_status(self):
        """L·∫•y tr·∫°ng th√°i c·ªßa h·ªá th·ªëng th√¥ng b√°o t·ª± ƒë·ªông"""
        status = {
            "active": self.active,
            "monitored_coins": self.monitored_coins,
            "scheduled_jobs": len(schedule.get_jobs()) if self.active else 0,
            "last_notification": {symbol: time.strftime("%Y-%m-%d %H:%M:%S") 
                                 for symbol, time in self.last_notification_time.items()}
        }
        return status
    
    def test_notification(self, symbol="BTCUSDT"):
        """G·ª≠i th√¥ng b√°o ph√¢n t√≠ch th·ª≠ nghi·ªám"""
        logger.info(f"G·ª≠i th√¥ng b√°o th·ª≠ nghi·ªám cho {symbol}")
        return self.send_single_coin_analysis(symbol)

# T·∫°o m·ªôt instance to√†n c·ª•c c·ªßa AutoMarketNotifier
auto_notifier = None

def get_auto_notifier():
    """Tr·∫£ v·ªÅ instance to√†n c·ª•c c·ªßa AutoMarketNotifier"""
    global auto_notifier
    if auto_notifier is None:
        auto_notifier = AutoMarketNotifier()
    return auto_notifier

# H√†m n√†y ƒë∆∞·ª£c g·ªçi t·ª´ main.py ƒë·ªÉ kh·ªüi ƒë·ªông h·ªá th·ªëng th√¥ng b√°o t·ª± ƒë·ªông
def start_auto_notifier():
    """Kh·ªüi ƒë·ªông h·ªá th·ªëng th√¥ng b√°o t·ª± ƒë·ªông"""
    notifier = get_auto_notifier()
    return notifier.start()

if __name__ == "__main__":
    # Khi ch·∫°y file n√†y tr·ª±c ti·∫øp, kh·ªüi ƒë·ªông h·ªá th·ªëng v√† g·ª≠i th√¥ng b√°o th·ª≠ nghi·ªám
    logging.info("Kh·ªüi ƒë·ªông h·ªá th·ªëng th√¥ng b√°o t·ª± ƒë·ªông tr·ª±c ti·∫øp")
    notifier = get_auto_notifier()
    notifier.start()
    
    # G·ª≠i th√¥ng b√°o th·ª≠ nghi·ªám
    notifier.test_notification("BTCUSDT")
    
    # Gi·ªØ cho ch∆∞∆°ng tr√¨nh ch·∫°y
    try:
        while True:
            time.sleep(60)
    except KeyboardInterrupt:
        notifier.stop()
        logging.info("ƒê√£ d·ª´ng h·ªá th·ªëng th√¥ng b√°o t·ª± ƒë·ªông")